{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting Started","text":"<p>System Requirements</p> <p>To run Ocelescope locally, you must have Docker and Docker Compose installed on your system.</p> <p>To get Ocelescope running docker compose. To run ocelescope you can just use the below docker compose script.</p> docker-compose.yaml<pre><code>services:\n  backend:\n    image: grkmr/ocelescope_backend:latest\n    volumes:\n      - plugins_store:/plugins\n    restart: unless-stopped\n\n  frontend:\n    image: grkmr/ocelescope_frontend:latest\n    ports:\n      - \"3000:3000\"\n    restart: unless-stopped\n\nvolumes:\n  plugins_store:\n</code></pre> <p> Download</p>"},{"location":"#starting-the-services","title":"Starting the Services","text":"<p>Run the following command in the same directory as your <code>docker-compose.yml</code>:</p> <pre><code>docker compose up -d\n</code></pre> <p>This will start both the backend (API) and frontend (web interface).</p>"},{"location":"#uploading-plugins","title":"Uploading Plugins","text":"<p>You can upload plugins directly from the web interface at:</p> <p>\ud83d\udc49 http://localhost:3000/plugins</p> <p>Uploaded plugins will be stored in the <code>plugins_store</code> volume and made available for execution.</p>"},{"location":"#stopping-ocelescope","title":"Stopping Ocelescope","text":"<p>To stop the services, run:</p> <pre><code>docker compose down\n</code></pre>"},{"location":"#example-plugins","title":"Example Plugins","text":"<p>Here are some example plugins you can explore and use with Ocelescope</p> <ul> <li> <p> PM4PY Discovery</p> <p>Discover object-centric process models through the discovery algorithms of the PM4PY python library</p> <p> Download</p> </li> <li> <p> TOTeM</p> <p>Generate Temporal Object Type Models ( TOTeM) to uncover type-level temporal and cardinality relations in event logs</p> <p> Download</p> </li> <li> <p> OC-DECLARE</p> <p>Discover and check object-centric declarative process constraints ( OC-DECLARE) from object-centric event logs. Proof of concept for using Rust via Python bindings in Ocelescope plugins.</p> <p> Download</p> </li> <li> <p> Discqvery</p> <p>Proof of concept for extended OCELs with  quantity states to better model logistics processes. An example extended log is available here.</p> <p> Download</p> </li> <li> <p> OCEL Graph</p> <p>Result of the plugin development tutorial: generates an OCEL Graph (spanning tree) from a selected object/event root to visualize relationships in an event log. Follow the tutorial here.</p> <p> Download</p> </li> </ul>"},{"location":"evaluation/plugin/","title":"Plugin Evaluation","text":"<p>In this evaluation, you will integrate a process mining implementation into Ocelescope by creating a plugin. The goal is to create a new plugin using the existing Ocelescope system and its documentation.</p> <p>Let\u2019s say you have already written two Python functions:</p> <ol> <li> <p>A discovery function (<code>discover_dfg</code>) that discovers an object-centric directly-follows graph (OC-DFG) from an Object-Centric Event Log (OCEL).    It returns a list of tuples in the form  <code>(activity_1, object_type, activity_2)</code>,  where each tuple means that <code>activity_2</code> directly follows <code>activity_1</code>, for the given <code>object_type</code>.    Start and end activities use <code>None</code> to indicate the absence of a preceding or following activity.</p> <p>Example Output of discover_dfg</p> <p>    Visualization of a possible output from <code>discover_dfg</code>: [(None, Order, Create Order), (Create Order, Order, Pack Item), (Pack Item, Order, Ship Order), (Ship Order, Order, None), (None, Item, Pack Item), (Pack Item, Item, None)].    </p> </li> <li> <p>A visualization function (<code>convert_dfg_to_graphviz</code>) that creates and returns a Graphviz <code>Digraph</code> instance representing the DFG, which can later be used to generate images.</p> </li> </ol> <p>By the end of this evaluation, you will have a working plugin that looks like this:</p> Example of a completed OC-DFG discovery plugin in Ocelescope. <p>For additional context or examples, you can use the Plugin Development Guide and the Tutorial. Everything you need to complete this evaluation is included here, but if you're curious and want to explore the topic further, those guides provide a deeper look into plugin development in Ocelescope.</p>"},{"location":"evaluation/plugin/#step-1-crash-course-in-ocelescope","title":"Step 1: Crash course in Ocelescope","text":"<p>Before we start building our plugin, let's take a quick look at the main building blocks of an Ocelescope plugin. Understanding these core concepts will make it easier to follow the next implementation steps.</p>"},{"location":"evaluation/plugin/#plugin-class","title":"Plugin Class","text":"<p>An Ocelescope plugin is a collection of Python functions grouped inside a class that inherits from the base <code>Plugin</code> class provided by the <code>ocelescope</code> package.</p> <p>Each plugin includes basic metadata, such as its name, version, and description, defined as class variables. Each function inside a plugin class that is decorated with <code>@plugin_method</code> becomes a callable action in the Ocelescope interface.</p> Example of an Ocelescope plugin in code and in the app."},{"location":"evaluation/plugin/#resources","title":"Resources","text":"<p>Resources are Python classes that can be used as inputs and outputs of plugin methods. They can represent process models, results of performance analyses, or any other structured data.</p> <p>Resources returned by plugin methods are automatically saved and can be reused as inputs for other methods. A resource is a Python class that inherits from <code>ocelescope.Resource</code>.</p> <p>A resource can optionally implement a visualization function, which returns one of Ocelescope\u2019s built-in visualization types. This allows the resource to be displayed automatically in the frontend.</p> A resource used to store activity counts. On the left its Python implementation; on the right, its visualization in Ocelescope."},{"location":"evaluation/plugin/#plugin-methods","title":"Plugin Methods","text":"<p>As discussed earlier, plugin methods are functions defined inside a plugin class. Their input parameters automatically generate a corresponding form in the Ocelescope frontend.</p> <p>A plugin method can have any number of parameters of type <code>OCEL</code> or <code>Resource</code>. In addition, it can include one plugin input parameter, defined by creating a custom class that inherits from the <code>PluginInput</code> base class provided by the <code>ocelescope</code> package. This custom class, called a configuration input, defines the user-configurable parameters for the plugin method.</p> Example: Defining a Plugin Method with an OCEL and a Custom Input Class <p>The following example shows how a plugin method can include both an <code>OCEL</code> parameter and a custom input class that inherits from <code>PluginInput</code>. The input class adds extra configurable parameters, in this case a numeric <code>frequency</code> field.</p> <pre><code>from ocelescope import OCEL, Plugin, PluginInput, plugin_method\n\nclass FrequencyInput(PluginInput):\n    \"\"\"Defines the input parameter for the frequency filter plugin.\"\"\"\n    frequency: int\n\nclass FrequencyFilterPlugin(Plugin):\n    ...\n\n    @plugin_method(\n        label=\"Filter Infrequent Object Types\",\n        description=\"Removes object types that occur less than the given frequency threshold.\"\n    )\n    def filter_infrequent(\n        self,\n        ocel: OCEL,\n        input: FrequencyInput,\n    ) -&gt; OCEL:...\n</code></pre> <p>You can also define special OCEL-dependent fields within the same class using the <code>OCEL_FIELD</code> helper. This helper links a field to the <code>OCEL</code> parameter of a plugin method, allowing you to create input fields that are automatically populated with elements such as object types, activities, or attribute names from the referenced OCEL log.</p> Example: Using OCEL-dependent fields <pre><code>from ocelescope import OCEL, Plugin, PluginInput, plugin_method, OCEL_FIELD\n\nclass Input(PluginInput):\n    event_types: list[str] = OCEL_FIELD(\n        ocel_id=\"ocel\",\n        field_type=\"event_type\",\n    )\n\nclass EventTypeFilter(Plugin):\n    label = \"Event Type Filter\"\n    description = \"A plugin that filters out selected event types\"\n    version = \"0.1.0\"\n\n    @plugin_method(label=\"Filter Events\", description=\"Filters events by type\")\n    def filter_out_events(\n        self,\n        ocel: OCEL,\n        input: Input,\n    ) -&gt; OCEL:\n        ...\n</code></pre> <p>This example shows how to define OCEL-dependent fields using the <code>OCEL_FIELD</code> helper, which links a field (here, <code>event_types</code>) to the <code>OCEL</code> parameter of the plugin method. The <code>ocel_id</code> value must match the name of the corresponding <code>OCEL</code> parameter.</p> A plugin method with its custom input class. On the left is the Python code, and on the right is the automatically generated form in Ocelescope."},{"location":"evaluation/plugin/#step-2-set-up-your-environment","title":"Step 2: Set Up Your Environment","text":"<p>Let's start by setting up the minimal Ocelescope plugin template. You can choose one of the following two methods to prepare your project.</p>"},{"location":"evaluation/plugin/#option-a-clone-the-template-from-github","title":"Option A - Clone the Template from GitHub","text":"<p>Clone the minimal plugin template directly from  Github (link to the repository):</p> <pre><code>git clone https://github.com/Grkmr/minimal-plugin.git\ncd minimal-plugin\n</code></pre>"},{"location":"evaluation/plugin/#option-b-generate-a-new-project-with-cookiecutter","title":"Option B - Generate a New Project with Cookiecutter","text":"<p>Alternatively, you can generate a new plugin project using Cookiecutter through uv:</p> <p>Warning</p> <p>When running the Cookiecutter template, always use the default options (press  Enter for each prompt). This ensures the generated project matches the structure expected in this evaluation.</p> <pre><code>uvx cookiecutter gh:rwth-pads/ocelescope --directory template\n</code></pre> <p>When you\u2019ve completed the setup steps above, your project directory should look like this:</p> <pre><code>minimal-plugin/ &lt;- root\n\u251c\u2500 LICENSE\n\u251c\u2500 README.md\n\u251c\u2500 pyproject.toml\n\u251c\u2500 requirements.txt\n\u251c\u2500 src/\n\u2502  \u251c\u2500 minimal_plugin/\n\u2502  \u2502  \u251c\u2500 __init__.py\n\u2502  \u2502  \u251c\u2500 plugin.py\n</code></pre>"},{"location":"evaluation/plugin/#install-dependencies","title":"Install Dependencies","text":"<p>Navigate to the root of the project and install all dependencies using your preferred package manager.</p> Warning <p>This evaluation requires Python 3.13. Make sure you have it installed  before continuing.</p> <p>Example</p> <pre><code># With uv\nuv sync\n\n# Or with pip\npip install -r requirements.txt\n</code></pre>"},{"location":"evaluation/plugin/#step-3-implement-the-plugin","title":"Step 3: Implement the Plugin","text":"<p>After setting up the project and becoming familiar with how Ocelescope plugins work, we'll now implement our first real plugin: a discovery plugin for object-centric directly-follows graph (OC-DFGs), as introduced earlier.</p> <p>The plugin will have the following components:</p> <p>Inputs</p> <ul> <li>An OCEL log  </li> <li>A list of object types to include in the discovery  </li> </ul> <p>Outputs</p> <ul> <li>A custom OC-DFG Resource containing the discovered directly-follows graph  </li> </ul>"},{"location":"evaluation/plugin/#step-31-prepare-the-template","title":"Step 3.1 Prepare the Template","text":"<p>The plugin template we set up earlier provides a <code>plugin.py</code> file that already includes boilerplate code for a minimal Ocelescope plugin. It contains a plugin class, a resource, and an input class.</p> <p>Initial state of <code>plugin.py</code></p> <pre><code>from typing import Annotated\n\nfrom ocelescope import OCEL, OCELAnnotation, Plugin, PluginInput, Resource, plugin_method\n\nclass MinimalResource(Resource):\n    label = \"Minimal Resource\"\n    description = \"A minimal resource\"\n\n    def visualize(self) -&gt; None:\n        pass\n\nclass Input(PluginInput):\n    pass\n\nclass MinimalPlugin(Plugin):\n    label = \"Minimal Plugin\"\n    description = \"An Ocelescope plugin\"\n    version = \"0.1.0\"\n\n    @plugin_method(label=\"Example Method\", description=\"An example plugin method\")\n    def example(\n        self,\n        ocel: Annotated[OCEL, OCELAnnotation(label=\"Event Log\")],\n        input: Input,\n    ) -&gt; MinimalResource:\n        return MinimalResource()\n</code></pre>"},{"location":"evaluation/plugin/#rename-the-resource","title":"Rename the Resource","text":"<ol> <li>Rename the class <code>MinimalResource</code> to <code>DFG</code>.  </li> <li>Update the <code>label</code> and <code>description</code> to indicate that the resource represents an object-centric directly-follows graph.</li> </ol>"},{"location":"evaluation/plugin/#rename-the-plugin-class","title":"Rename the Plugin Class","text":"<ol> <li>Rename the class <code>MinimalPlugin</code> to a meaningful name, for example <code>DiscoverDFG</code>.  </li> <li>Update the <code>label</code> and <code>description</code> fields to describe the new plugin.  </li> <li> <p>Adapt the import in <code>__init__.py</code> to reflect the new class name.  </p> Tip <p>The Ocelescope app looks inside the <code>__init__.py</code> file to locate your plugin class. Make sure to update both the import and the <code>__all__</code> list when renaming your plugin.</p> __init__.py<pre><code>from .plugin import MinimalPlugin  # Rename this\n\n__all__ = [\n    \"MinimalPlugin\",  # Rename this\n]\n</code></pre> </li> </ol>"},{"location":"evaluation/plugin/#rename-the-plugin-method","title":"Rename the Plugin Method","text":"<ol> <li>Rename the method <code>example</code> to a descriptive name, for example <code>discover</code>.  </li> <li>Update the method\u2019s <code>label</code> and <code>description</code> fields to describe its purpose.  </li> <li> <p>Adjust the return type hint of the method to use the renamed resource (for example, change <code>MinimalResource</code> to <code>DFG</code>).</p> What is a Type Hint? <p>Type hints are annotations that specify what type of value a function returns or expects as input. They are written after a function definition using an arrow (<code>-&gt;</code>).  </p> <pre><code>def discover(...) -&gt; DFG:\n    ...\n</code></pre> </li> </ol>"},{"location":"evaluation/plugin/#add-the-utility-file","title":"Add the Utility File","text":"<p>To keep your plugin code clean and organized, we will place the discovery and visualization functions in a separate file named <code>util.py</code>.</p> <p>You can either download the ready-made  util.py file or create a new <code>util.py</code> file yourself. In both cases, place it next to your <code>plugin.py</code> (i.e. at <code>src/minimal_plugin/util.py</code>).</p> The Discovery and Visualization implementation <p>You don\u2019t need to fully understand the implementation of these functions to complete this evaluation. They are provided as ready-to-use helpers that you will later integrate into your Ocelescope plugin.</p> util.py<pre><code>import itertools\n\nimport pm4py\nfrom graphviz import Digraph\nfrom ocelescope import OCEL\n\n\ndef discover_dfg(\n    ocel: OCEL, used_object_types: list[str]\n) -&gt; list[tuple[str | None, str, str | None]]:\n    ocel_filtered = pm4py.filter_ocel_object_types(\n        ocel.ocel, used_object_types, positive=True\n    )\n    ocdfg = pm4py.discover_ocdfg(ocel_filtered)\n    edges: list[tuple[str | None, str, str | None]] = []\n    for object_type, raw_edges in ocdfg[\"edges\"][\"event_couples\"].items():\n        edges = edges + (\n            [(source, object_type, target) for source, target in raw_edges]\n        )\n\n        edges += [\n            (activity, object_type, None)\n            for object_type, activities in ocdfg[\"start_activities\"][\"events\"].items()\n            for activity in activities.keys()\n        ]\n\n        edges += [\n            (None, object_type, activity)\n            for object_type, activities in ocdfg[\"end_activities\"][\"events\"].items()\n            for activity in activities.keys()\n        ]\n    return edges\n\n\ndef convert_dfg_to_graphviz(dfg: list[tuple[str | None, str, str | None]]) -&gt; Digraph:\n    dot = Digraph(\"Ugly DFG\")\n    dot.attr(rankdir=\"LR\")\n\n    outer_nodes = set()\n    inner_sources = {}\n    inner_sinks = {}\n    edges_seen = set()\n    types = set()\n\n    for src, x, tgt in dfg:\n        if src is not None:\n            outer_nodes.add(src)\n        if tgt is not None:\n            outer_nodes.add(tgt)\n        if x is not None:\n            types.add(x)\n            inner_sources[x] = f\"source_{x}\"\n            inner_sinks[x] = f\"sink_{x}\"\n        edges_seen.add((src, x, tgt))\n\n    # A palette of colors\n    palette = [\n        \"red\",\n        \"blue\",\n        \"green\",\n        \"orange\",\n        \"purple\",\n        \"brown\",\n        \"gold\",\n        \"pink\",\n        \"cyan\",\n        \"magenta\",\n    ]\n    color_map = {x: c for x, c in zip(sorted(types), itertools.cycle(palette))}\n\n    # Outer nodes: neutral color\n    for n in outer_nodes:\n        dot.node(n, shape=\"rectangle\", style=\"filled\", fillcolor=\"lightgray\")\n\n    # Sources and sinks: colored small circles, with xlabel underneath\n    for x in types:\n        color = color_map[x]\n        dot.node(\n            inner_sources[x],\n            shape=\"circle\",\n            style=\"filled\",\n            fillcolor=color,\n            width=\"1\",\n            height=\"1\",\n            fixedsize=\"true\",\n            label=\"\",\n            xlabel=x,\n        )\n        dot.node(\n            inner_sinks[x],\n            shape=\"circle\",\n            style=\"filled\",\n            fillcolor=color,\n            width=\"1\",\n            height=\"1\",\n            label=\"\",\n            fixedsize=\"true\",\n            xlabel=x,\n        )\n\n    # Rank groups\n    with dot.subgraph() as s:\n        s.attr(rank=\"same\")\n        for n in inner_sources.values():\n            s.node(n)\n\n    with dot.subgraph() as s:\n        s.attr(rank=\"same\")\n        for n in inner_sinks.values():\n            s.node(n)\n\n    # Add edges with thicker lines\n    for src, x, tgt in edges_seen:\n        if x is None:\n            continue\n        color = color_map[x]\n        if src is not None and tgt is not None:\n            dot.edge(src, tgt, color=color, penwidth=\"2\")\n        elif src is None and tgt is not None:\n            dot.edge(tgt, inner_sinks[x], color=color, penwidth=\"2\")\n        elif src is not None and tgt is None:\n            dot.edge(inner_sources[x], src, color=color, penwidth=\"2\")\n\n    return dot\n</code></pre> <p>After completing the previous steps, your project directory should look like this:</p> <pre><code>minimal-plugin/\n\u251c\u2500 ...\n\u251c\u2500 src/\n\u2502  \u251c\u2500 minimal_plugin/\n\u2502  \u2502  \u251c\u2500 __init__.py\n\u2502  \u2502  \u251c\u2500 plugin.py\n\u2502  \u2502  \u251c\u2500 util.py\n</code></pre> Solution 1 plugin.py<pre><code>from typing import Annotated\n\nfrom ocelescope import OCEL, OCELAnnotation, Plugin, PluginInput, Resource, plugin_method\n\n\nclass DFG(Resource):\n    label = \"DFG\"\n    description = \"An object-centric directly follows graph\"\n\n    def visualize(self) -&gt; None:\n        pass\n\n\nclass Input(PluginInput):\n    pass\n\n\nclass DiscoverDFG(Plugin):\n    label = \"DFG Discovery\"\n    description = \"A plugin for discovering object-centric directly-follows graphs\"\n    version = \"0.1.0\"\n\n    @plugin_method(label=\"Discover DFG\", description=\"Discovers an object-centric directly-follows graph\")\n    def discover(\n        self,\n        ocel: Annotated[OCEL, OCELAnnotation(label=\"Event Log\")],\n        input: Input,\n    ) -&gt; DFG:\n        return DFG()\n</code></pre> __init__.py<pre><code>from .plugin import DiscoverDFG\n\n__all__ = [\n    \"DiscoverDFG\",\n]\n</code></pre>"},{"location":"evaluation/plugin/#step-32-integrate-the-discovery-functions","title":"Step 3.2 Integrate the Discovery Functions","text":"<p>Now that the structure is in place, we can integrate the discovery and visualization functions into the plugin to make it functional.</p>"},{"location":"evaluation/plugin/#extend-the-resource","title":"Extend the Resource","text":"<p>Since our plugin returns a directly-follows graph, we should add an <code>edges</code> field (class attribute) to our DFG resource to store the discovered relationships.</p> <p>The discovery method provided in the <code>util.py</code> returns the OC-DFG as a list of tuples <code>discover_dfg(...) -&gt; list[tuple[str | None , str, str | None]]</code>. To integrate this into our Resource, extend your <code>DFG</code> class to hold this data.</p> <ol> <li> <p>Add a field (class attribute) named <code>edges</code> with the following type:</p> <pre><code>  list[tuple[str | None, str, str | None]]\n</code></pre> </li> </ol> Solution 2 plugin.py<pre><code>class DFG(Resource):\n    label = \"DFG\"\n    description = \"An object-centric directly follows graph\"\n\n    edges: list[tuple[str | None, str, str | None]]\n\n    def visualize(self) -&gt; None:\n        pass\n</code></pre>"},{"location":"evaluation/plugin/#add-a-visualization-to-the-resource","title":"Add a visualization to the Resource","text":"<p>Our <code>DFG</code> resource can already be used as both an input and an output, but currently it only stores data without any visual representation.</p> <p>To display it visually in the Ocelescope frontend, we can extend its <code>visualize</code> method.</p> <p>The provided <code>util.py</code> file already includes a helper function, <code>convert_dfg_to_graphviz</code>, which takes the resource's <code>edges</code> as input and returns a <code>graphviz.Digraph</code> instance.</p> <p>Ocelescope supports several visualization types, including <code>DotVis</code>, which renders Graphviz DOT strings.</p> <p>A <code>DotVis</code> instance can be created directly from a <code>graphviz.Digraph</code> by using <code>DotVis.from_graphviz(...)</code>.</p> <p>Inside the <code>visualize</code> method of your <code>DFG</code> class:</p> <ol> <li> <p>Import the <code>convert_dfg_to_graphviz</code> from the <code>util.py</code> as a relative import.</p> Use only relative imports <p>Ocelescope plugins must use relative imports when referencing files in the same directory.</p> <pre><code>from minimal_plugin.util import convert_dfg_to_graphviz   # \u274c Do not use absolute imports\nfrom util import convert_dfg_to_graphviz                  # \u274c Do not use top-level imports\nfrom .util import convert_dfg_to_graphviz                 # \u2705 Use relative imports instead\n</code></pre> </li> <li> <p>Call the <code>convert_dfg_to_graphviz</code> with the resource's <code>edges</code> field.</p> </li> <li> <p>Return a <code>DotVis</code> instance created with <code>DotVis.from_graphviz(...)</code>.</p> <p>Tip</p> <ul> <li>You can access the edges through <code>self.edges</code>, assuming the field in your <code>DFG</code> resource is named <code>edges</code>.</li> <li>Make sure <code>DotVis</code> is imported from the <code>ocelescope</code> package before using it:   <pre><code>from ocelescope import DotVis\n</code></pre></li> </ul> </li> </ol> Solution 3 plugin.py<pre><code>from ocelescope import OCEL, DotVis, OCELAnnotation, Plugin, PluginInput, Resource, plugin_method\n\nfrom .util import convert_dfg_to_graphviz\n\n\nclass DFG(Resource):\n    label = \"DFG\"\n    description = \"An object-centric directly follows graph\"\n\n    edges: list[tuple[str | None, str, str | None]]\n\n    def visualize(self):\n        graphviz_instance = convert_dfg_to_graphviz(self.edges)\n\n        return DotVis.from_graphviz(graphviz_instance)\n</code></pre>"},{"location":"evaluation/plugin/#extend-the-input-class","title":"Extend the Input Class","text":"<p>Now let's define the input of the <code>discover</code> function. Since we renamed the original example method inside the plugin class, it should already include an OCEL parameter named <code>ocel</code>.</p> <p>Because the discovery function allows filtering by object type, we should also allow the user to select which object types to include. This is done by extending the <code>Input</code> class.</p> <p>Inside the <code>Input</code> class (which inherits from <code>PluginInput</code>):</p> <ol> <li>Remove the existing <code>pass</code> statement.</li> <li>Add a new field (class attribute) called <code>object_types</code> with the type <code>list[str]</code></li> <li>Turn it into an OCEL-dependent field using the <code>OCEL_FIELD</code> helper, setting the <code>field_type</code> to <code>\"object_type\"</code></li> </ol> Solution 4 plugin.py<pre><code>from ocelescope import OCEL, OCEL_FIELD, DotVis, OCELAnnotation, Plugin, PluginInput, Resource, plugin_method\n\nclass Input(PluginInput):\n    object_types: list[str] = OCEL_FIELD(field_type=\"object_type\", ocel_id=\"ocel\")\n</code></pre>"},{"location":"evaluation/plugin/#integrate-the-implementation","title":"Integrate the Implementation","text":"<p>After defining the inputs for our discovery and the <code>Resource</code> that will hold the result, we can now connect everything in the <code>discover</code> method of our plugin class.</p> <p>In the <code>discover</code> method:</p> <ol> <li> <p>Import the <code>discover_dfg</code> function as a relative import.</p> Use only relative imports <p>Ocelescope plugins must use relative imports when referencing files in the same directory.</p> <pre><code>from minimal_plugin.util import discover_dfg  # \u274c Do not use absolute imports\nfrom util import discover_dfg                 # \u274c Do not use top-level imports\nfrom .util import discover_dfg                # \u2705 Use relative imports instead\n</code></pre> </li> <li> <p>Call the <code>discover_dfg</code> with the <code>ocel</code> parameter and the <code>object_types</code> field from the input class, then use the result to create a new instance of the <code>DFG</code> resource.</p> <p>Tip</p> <p>Always instantiate the <code>DFG</code> resource using named parameters.  </p> <pre><code>return DFG(edges=discovery_result)   # \u2705 Correct \u2014 use named parameters\nreturn DFG(discovery_result)         # \u274c Incorrect \u2014 avoid positional arguments\n</code></pre> </li> <li> <p>Return the created <code>DFG</code> resource</p> </li> </ol> Solution 5 plugin.py<pre><code>from .util import convert_dfg_to_graphviz, discover_dfg\n\nclass DiscoverDFG(Plugin):\n    label = \"DFG Discovery\"\n    description = \"A plugin for discovering object-centric directly-follows graphs\"\n    version = \"0.1.0\"\n\n    @plugin_method(label=\"Discover DFG\", description=\"Discovers an object-centric directly-follows graph\")\n    def discover(\n        self,\n        ocel: Annotated[OCEL, OCELAnnotation(label=\"Event Log\")],\n        input: Input,\n    ) -&gt; DFG:\n        edges = discover_dfg(ocel=ocel, used_object_types=input.object_types)\n\n        return DFG(edges=edges)\n</code></pre>"},{"location":"evaluation/plugin/#step-4-build-your-plugin","title":"Step 4: Build your plugin","text":"<p>That's it! The final step is to build your plugin. You can do this in one of two ways:</p> <ol> <li> <p>Manually, by creating a ZIP archive yourself:</p> <pre><code>DfgDiscovery.zip/\n\u251c\u2500 plugin/\n\u2502  \u251c\u2500 plugin.py\n\u2502  \u251c\u2500 util.py\n\u2502  \u251c\u2500 __init__.py\n</code></pre> </li> <li> <p>Using the built-in Ocelescope build command (recommended):</p> <p>Run the build command in the root of your project.</p> <p>Make sure to execute it within the same Python environment where you installed your dependencies.</p> <pre><code>ocelescope build\n</code></pre> <p>Or, depending on how you manage your environment:</p> <pre><code># If using pipx\npipx run ocelescope build\n\n# If using uvx\nuvx ocelescope build\n\n# If using uv\nuv run ocelescope build\n</code></pre> </li> </ol> <p>After building, you'll find your packaged plugin as a <code>.zip</code> file inside the <code>dist/</code> directory.</p> Solution 6 <p> Download Plugin</p> <p>plugin.py<pre><code>from typing import Annotated\n\nfrom ocelescope import OCEL, OCEL_FIELD, DotVis, OCELAnnotation, Plugin, PluginInput, Resource, plugin_method\n\nfrom .util import convert_dfg_to_graphviz, discover_dfg\n\nclass DFG(Resource):\n    label = \"DFG\"\n    description = \"An object-centric directly follows graph\"\n\n    edges: list[tuple[str | None, str, str | None]]\n\n    def visualize(self):\n        graphviz_instance = convert_dfg_to_graphviz(self.edges)\n\n        return DotVis.from_graphviz(graphviz_instance)\n\nclass Input(PluginInput):\n    object_types: list[str] = OCEL_FIELD(field_type=\"object_type\", ocel_id=\"ocel\")\n\nclass DiscoverDFG(Plugin):\n    label = \"DFG Discovery\"\n    description = \"A plugin for discovering object-centric directly-follows graphs\"\n    version = \"0.1.0\"\n\n    @plugin_method(label=\"Discover DFG\", description=\"Discovers an object-centric directly-follows graph\")\n    def discover(\n        self,\n        ocel: Annotated[OCEL, OCELAnnotation(label=\"Event Log\")],\n        input: Input,\n    ) -&gt; DFG:\n        edges = discover_dfg(ocel=ocel, used_object_types=input.object_types)\n\n        return DFG(edges=edges)\n</code></pre> __init__.py<pre><code>from .plugin import DiscoverDFG\n\n__all__ = [\n    \"DiscoverDFG\",\n]\n</code></pre></p> <p>If you'd like, you can upload the ZIP file in the Ocelescope interface to test your plugin directly.</p> <p>Once finished, return to the evaluation form to complete your assessment.</p>"},{"location":"evaluation/tool/","title":"Tool Evaluation","text":"<p>In this evaluation, we assess the usability and functionality of Ocelescope by simulating a common research scenario: trying out the implementation of a tool introduced in a scientific paper. As an example, we use the plugin for TOTeM \u2014 a technique proposed for object-centric process mining.</p> <p>System Requirements</p> <p>To run Ocelescope locally, you must have Docker and Docker Compose installed on your system.</p>"},{"location":"evaluation/tool/#step-1-get-ocelescope-running","title":"Step 1: Get Ocelescope Running","text":"<p>The first step is to get Ocelescope up and running on your machine.</p> <p>Please follow the instructions in the Getting Started section to set up and launch Ocelescope using Docker.</p> <p>Ocelescope Frontend</p> <p>After starting the application, access the frontend at http://localhost:3000.</p>"},{"location":"evaluation/tool/#step-2-download-and-upload-the-totem-plugin","title":"Step 2: Download and Upload the TOTeM Plugin","text":"<p>First, download the TOTeM plugin using the button below:</p> <ul> <li> <p> TOTeM</p> <p>Generate Temporal Object Type Models (TOTeM) to uncover type-level temporal and cardinality relations in event logs</p> <p> Download</p> </li> </ul> <p>Next, upload the plugin into Ocelescope. Once uploaded, the TOTeM plugin will appear in the plugin list and is ready to use.</p>"},{"location":"evaluation/tool/#step-3-load-a-default-event-log","title":"Step 3: Load a Default Event Log","text":"<p>To run the plugin, you need an event log. Ocelescope provides several example OCEL logs that you can use for testing.</p> <p>In this example, we will use the Container Logistics log.</p> <p>Once imported, the log will appear in your list of available logs and can be used with the TOTeM plugin.</p>"},{"location":"evaluation/tool/#step-4-run-the-totem-plugin","title":"Step 4: Run the TOTeM Plugin","text":"<p>Once the Container Logistics log is loaded, navigate to the TOTeM plugin in Ocelescope and run the Discover TOTeM method. Try different <code>\u03c4</code> (tau) values to explore how the results change \u2014 for example, use <code>0.9</code> and <code>0.3</code>.</p> <p>After running the method, download the resulting files.</p> <p>When you're done, return to the evaluation form and upload the generated results.</p>"},{"location":"plugins/","title":"Overview","text":"<p>Plugins are the primary way to extend Ocelescope with custom functionality \u2014 and they are designed to be easy to write, distribute, and use.</p> <ul> <li>No frontend knowledge required \u2013 Create plugins entirely in Python; the frontend UI is generated automatically.</li> <li>Simple packaging \u2013 Bundle your plugin as a single ZIP file and upload it at runtime.</li> </ul> <p>An Ocelescope plugin is built from four main components:</p> <ol> <li>Resource Definitions \u2013 Describe the plugin\u2019s inputs and outputs.</li> <li>OCEL Extensions \u2013 Extend the OCEL 2.0 event log structure in a standardized way.</li> <li>Input Schemas \u2013 Python classes that define user-configurable parameters and generate the UI form.</li> <li>Plugin Class \u2013 Implements the plugin\u2019s methods, metadata, and execution logic.</li> </ol> <p>This guide walks you through each component step by step, followed by a tutorial to help you build a complete plugin from scratch.</p>"},{"location":"plugins/extension/","title":"Extensions","text":"<p>In some use cases, OCEL logs contain more information than is specified in the OCEL 2.0 standard. To support these cases in a standardized and portable way, Ocelescope provides OCEL extensions.</p> <p>Extensions allow you to add custom data to OCEL logs and store or load that data alongside the main event and object logs.</p>"},{"location":"plugins/extension/#defining-an-ocel-extension","title":"Defining an OCEL Extension","text":"<p>To define an extension, create a class that inherits from <code>OCELExtension</code> (provided by the <code>ocelescope</code> package). This class defines how the extension is detected, imported, and exported.</p> <p>Each extension must define the following attributes and methods:</p> <ul> <li><code>name</code>: A short identifier for the extension</li> <li><code>description</code>: A human-readable explanation of what the extension adds</li> <li><code>version</code>: The extension\u2019s version</li> <li><code>supported_extensions</code>: A list of file types the extension supports (e.g., <code>[\".xmlocel\"]</code>)</li> </ul> <p>The class must also implement three key methods:</p> <ul> <li> <p><code>has_extension(path: Path) -&gt; bool</code>   Checks if the extension is present at the given file path</p> </li> <li> <p><code>import_extension(ocel: OCEL, path: Path) -&gt; OCELExtension</code>   Loads the extension data from the path and returns an instance</p> </li> <li> <p><code>export_extension(path: Path) -&gt; None</code>   Saves the extension data to the path</p> </li> </ul>"},{"location":"plugins/extension/#base-class-ocelextension","title":"Base Class: <code>OCELExtension</code>","text":"<pre><code>from abc import ABC, abstractmethod\nfrom pathlib import Path\nfrom typing import TypeVar\n\nfrom ocelescope.ocel.constants import OCELFileExtensions\n\nT = TypeVar(\"T\", bound=\"OCELExtension\")\n\nclass OCELExtension(ABC):\n    \"\"\"\n    Abstract base class for OCEL extensions that can be imported/exported from a file path.\n    \"\"\"\n\n    name: str\n    description: str\n    version: str\n    supported_extensions: list[OCELFileExtensions]\n\n    @staticmethod\n    @abstractmethod\n    def has_extension(path: Path) -&gt; bool:\n        pass\n\n    @classmethod\n    @abstractmethod\n    def import_extension(cls: type[T], ocel: \"OCEL\", path: Path) -&gt; T:\n        pass\n\n    @abstractmethod\n    def export_extension(self, path: Path) -&gt; None:\n        pass\n</code></pre>"},{"location":"plugins/extension/#example-hello-world-extension","title":"Example: \u201cHello World\u201d Extension","text":"<p>This version of the <code>HelloWorldExtension</code> stores a message directly inside the <code>.jsonocel</code> file under a custom top-level field like <code>\"hello_message\"</code>. It only loads if that field is present.</p> <pre><code>import json\nfrom pathlib import Path\nfrom ocelescope import OCEL, OCELExtension\n\nclass HelloWorldExtension(OCELExtension):\n    name = \"HelloWorld\"\n    description = \"Stores a simple message string in the .jsonocel file\"\n    version = \"1.0\"\n    supported_extensions = [\".jsonocel\"]\n\n    def __init__(self, ocel: OCEL, message: str = \"Hello from extension!\"):\n        self.ocel = ocel\n        self.message = message\n\n    @staticmethod\n    def has_extension(path: Path) -&gt; bool:\n        if path.suffix != \".jsonocel\":\n            return False\n\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                data = json.load(f)\n            return \"hello_message\" in data\n        except Exception:\n            return False\n\n    @classmethod\n    def import_extension(cls, ocel: OCEL, path: Path) -&gt; \"HelloWorldExtension\":\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n        message = data.get(\"hello_message\", \"No message found.\")\n        return cls(ocel, message=message)\n\n    def export_extension(self, path: Path) -&gt; None:\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                data = json.load(f)\n        except Exception:\n            data = {}\n\n        data[\"hello_message\"] = self.message\n\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(data, f, indent=2)\n</code></pre>"},{"location":"plugins/plugin_class/","title":"Plugin Class","text":"<p>In Ocelescope, plugins are implemented as Python classes that inherit from the base <code>Plugin</code> class provided by the <code>ocelescope</code> package. These classes follow a standardized structure to ensure compatibility across the platform.</p> <p>Each plugin class must be defined at the top level of the module. It cannot be nested inside another class or function. Additionally, each ZIP archive can contain only one plugin class.</p> <p>A plugin consists of two main components:</p> <ul> <li>Metadata: Provides descriptive information about the plugin, such as its name, version, and description.</li> <li>Plugin methods: Define the functional logic of the plugin. Each method must conform to a fixed number of inputs and outputs as expected by the system.</li> </ul>"},{"location":"plugins/plugin_class/#metadata","title":"Metadata","text":"<p>Plugin metadata is defined using class variables within the plugin class. These variables provide descriptive information about the plugin and are required for proper registration and display within the Ocelescope system.</p> <p>The metadata includes:</p> <ul> <li><code>name</code>: A short, human-readable name for the plugin.</li> <li><code>description</code>: A brief explanation of what the plugin does.</li> <li><code>version</code>: A version string (e.g., <code>\"1.0.0\"</code>).</li> </ul> An example plugin with metadata<pre><code>from ocelescope import Plugin\n\nclass ExamplePlugin(Plugin):\n    label = \"Example Plugin\"\n    description = \"An example plugin to demonstrate plugin metadata\"\n    version = \"1.0\"\n    ...\n</code></pre>"},{"location":"plugins/plugin_class/#methods","title":"Methods","text":"<p>Plugin methods are functions that can be executed within Ocelescope. They are defined as methods of the plugin class and must be decorated with the <code>@plugin_method</code> decorator. This decorator also attaches metadata to the method, making it discoverable and usable by the system.</p> <p>Once the plugin is loaded in the frontend, plugin methods become available for execution. A user interface form is automatically generated based on the method's defined inputs.</p> Structure of a plugin method<pre><code>from ocelescope import Plugin, plugin_method\n\nclass ExamplePlugin(Plugin):\n  ...\n  @plugin_method(\n    label=\"Discover Petri net\"\n    description=\"Discover an object-centric Petri net\"\n  )\n  def discover_petri_net(self, ...) -&gt; ...:\n    ...\n</code></pre>"},{"location":"plugins/plugin_class/#inputs","title":"Inputs","text":"<p>A plugin method can accept the following types of inputs:</p> <ul> <li> <p>Any number of OCEL objects   These are instances of the <code>OCEL</code> class provided by the <code>ocelescope</code> package.</p> </li> <li> <p>Any number of Resources   A detailed explanation of resources will be provided in a later section.</p> </li> <li> <p>One structured input object   This object allows for parameterized user input via a generated frontend form. While currently referred to as <code>PluginInput</code>, this name may change. Only one such input object is allowed per plugin method.</p> </li> </ul>"},{"location":"plugins/plugin_class/#ocel-inputs","title":"OCEL Inputs","text":"<p>OCEL inputs are passed to plugin methods as instances of the <code>OCEL</code> class provided by the <code>ocelescope</code> package. These inputs represent event logs and are selected by the user through the frontend interface.</p> <p>In the UI, OCEL inputs appear as dropdown (select) fields, allowing users to choose from the available logs in the current session.</p> <p>OCEL inputs can also be annotated with the <code>OCELAnnotation</code> to provide additional metadata, including:</p> <ul> <li>Label: A custom name shown in the frontend</li> <li>Description: A brief explanation of the input's purpose</li> <li>Extensions: A list of required OCEL extensions that must be present in the selected log</li> </ul> An example plugin with metadata<pre><code>from ocelescope import Plugin, OCEL\nfrom typing import Annotated\n\nclass ExamplePlugin(Plugin):\n  ...\n  @plugin_method(\n    label=\"Discover Petri net\",\n    description=\"Discover an object-centric Petri net\"\n  )\n  def discover_petri_net(\n      self,\n      log: Annotated[OCEL, OCELAnnotation(\n        label=\"A label for the OCEL\",\n        description=\"The log from which the Petri net is mined\",\n        extension=ExampleExtension\n      )]\n    )\n</code></pre>"},{"location":"plugins/plugin_class/#resource-inputs","title":"Resource Inputs","text":"<p>Resource inputs are passed to plugin methods as instances of the <code>Resource</code> class, in a similar way to OCEL inputs. These inputs represent external data or files that the plugin may need to operate on.</p> <p>In the frontend, users can select or upload resources, which are then made available to the plugin.</p> <p>Resource inputs can be annotated with the <code>ResourceAnnotation</code> to provide additional metadata, including:</p> <ul> <li>Label: A custom name displayed in the UI</li> <li>Description: A short explanation of what the resource is used for</li> </ul> An example plugin with metadata<pre><code>from ocelescope import Plugin, PetriNet, ResourceAnnotation\nfrom typing import Annotated\n\nclass ExamplePlugin(Plugin):\n  ...\n  @plugin_method(\n    label=\"Discover Petri net\",\n    description=\"Discover an object-centric Petri net\"\n  )\n  def check_conformance(\n      self,\n      log: OCEL,\n      petri_net: Annotated[PetriNet,ResourceAnnotation(\n                  label=\"A label for the Petri net\",\n                  description=\"The log on which the conformance should be checked\"\n                  )]\n    ) -&gt; ...:\n    ...\n</code></pre>"},{"location":"plugins/plugin_class/#configuration-inputs","title":"Configuration Inputs","text":"<p>Structured configuration inputs are defined by creating a subclass of the <code>PluginInput</code> class from the <code>ocelescope</code> package. This class contains all parameter fields required by the plugin method that are not OCEL logs or Resources.</p> <p>While the class can have any name, it must be assigned to the variable <code>input</code> in the plugin method. This tells Ocelescope which input schema to use when generating the frontend form.</p> <p>Each plugin method may use only one structured input.</p> A example configuration input for a discovery method<pre><code>from ocelescope import Plugin, PluginInput, plugin_method, OCEL\nfrom pydantic import Field\n\nclass DiscoverInput(PluginInput):\n    noise_threshold: float = Field(\n        ge=0.0,\n        le=1.0,\n        default=0.2,\n        title=\"Noise Threshold\",\n        description=\"Filter out infrequent behavior (0.0\u20131.0)\"\n    )\n    algorithm: str = Field(\n        default=\"Alpha Miner\",\n        title=\"Algorithm\",\n        description=\"The discovery algorithm to use\",\n        enum=[\"Alpha Miner\", \"Heuristics Miner\", \"Inductive Miner\"]\n    )\n\nclass ExamplePlugin(Plugin):\n\n    @plugin_method(\n        label=\"Discover Petri net\",\n        description=\"Discover an object-centric Petri net from an OCEL log\"\n    )\n    def discover_petri_net(\n        self,\n        log: OCEL,\n        input: DiscoverInput\n    ):\n        ...\n</code></pre>"},{"location":"plugins/plugin_class/#basic-input-fields","title":"Basic Input Fields","text":"<p>Basic input fields allow users to enter simple configuration values such as text, numbers, selections, or booleans. These fields are defined as attributes of the input class and use Pydantic\u2019s <code>Field()</code> function to add metadata and constraints.</p> <p>The most commonly used types are:</p> <ul> <li>Strings: Free text or selectable options  </li> <li>Numbers: With optional minimum and maximum bounds  </li> <li>Booleans: Shown as switches or checkboxes in the UI  </li> </ul> Example: String Input<pre><code>from ocelescope import PluginInput\nfrom pydantic import Field\n\nclass Input(PluginInput):\n    algorithm_name: str = Field(\n        title=\"Algorithm Name\",\n        description=\"Name of the analysis algorithm to use\",\n        default=\"Alpha Miner\"\n    )\n</code></pre> Example: Constrained Number Input<pre><code>threshold: float = Field(\n    ge=0.0,\n    le=1.0,\n    default=0.2,\n    title=\"Noise Threshold\",\n    description=\"Filter out infrequent behavior (0.0\u20131.0)\"\n)\n</code></pre> Example: Selection from Options<pre><code>method: Literal[\"average\", \"sum\", \"maximum\", \"minimum\"] = Field(\n    default=\"average\",\n    title=\"Aggregation Method\",\n    description=\"Choose how to aggregate results\",\n)\n</code></pre> Example: Boolean Switch<pre><code>include_metadata: bool = Field(\n    default=True,\n    title=\"Include Metadata\",\n    description=\"Whether to include additional metadata in results\"\n)\n</code></pre>"},{"location":"plugins/plugin_class/#ocel-dependent-selection-fields","title":"OCEL-Dependent Selection Fields","text":"<p>Sometimes, the available options in an input field depend on the contents of an OCEL log \u2014 for example, selecting activity types, object types, or attribute names. These are called OCEL-dependent selection fields.</p> <p>You can define them using the <code>OCEL_FIELD</code> helper from the <code>ocelescope</code> package. This creates a dynamic dropdown field populated from the specified OCEL input.</p> <p>Each <code>OCEL_FIELD</code> must include:</p> <ul> <li><code>field_type</code>: the type of OCEL data to pull (e.g., <code>\"event_type\"</code> or <code>\"object_type\"</code>)</li> <li><code>ocel_id</code>: the name of the OCEL input parameter this field depends on</li> </ul> <p>Example: Selecting Object Types from an OCEL</p> <pre><code>from ocelescope import Plugin, PluginInput, plugin_method, OCEL, OCEL_FIELD\nfrom pydantic import Field\n\nclass ObjectFilterInput(PluginInput, frozen=True):\n    object_types: list[str] = OCEL_FIELD(\n        title=\"Object Types\",\n        description=\"Select which object types to include in analysis\",\n        field_type=\"object_type\",\n        ocel_id=\"ocel\"  # Must match the name of the OCEL method parameter\n    )\n\nclass ExamplePlugin(Plugin):\n\n    @plugin_method(\n        label=\"Filter by Object Type\",\n        description=\"Filter the log based on selected object types\"\n    )\n    def filter_log(\n        self,\n        ocel: OCEL,\n        input: ObjectFilterInput\n    ):\n        ...\n</code></pre> <p>This allows the plugin form to stay in sync with the selected OCEL log, ensuring users can only choose valid options.</p>"},{"location":"plugins/plugin_class/#dynamically-computed-fields","title":"Dynamically Computed Fields","text":"<p>In some cases, the valid options for a field depend on other inputs or data passed to the plugin \u2014 including the selected OCEL log, Resources, or previously selected values. These are called dynamically computed fields.</p> <p>To define a dynamic field, use the <code>COMPUTED_SELECTION</code> helper from the <code>ocelescope</code> package. This creates a selection field whose options are calculated by a Python function at runtime.</p> <p>Each <code>COMPUTED_SELECTION</code> must specify:</p> <ul> <li><code>provider</code>: the name of a static method (or regular method) on the input class that returns the list of options.</li> </ul> <p>Provider function accepted arguments</p> Argument Description <code>inputs</code> Dictionary of current form values OCEL logs Selected OCEL(s) passed to the method Resources Resource instances available to the method <p>Example: Dynamic Attribute Selection Using Activities and Resource File</p> <pre><code>from ocelescope import (\n    Plugin, PluginInput, plugin_method, OCEL,\n    OCEL_FIELD, COMPUTED_SELECTION, Resource, ResourceAnnotation\n)\nfrom typing import Annotated\n\nclass AttributeSelectionInput(PluginInput):\n    activity_types: list[str] = OCEL_FIELD(\n        title=\"Activity Types\",\n        description=\"Select activities to analyze\",\n        field_type=\"event_type\",\n        ocel_id=\"log\"\n    )\n\n    event_attributes: list[str] = COMPUTED_SELECTION(\n        provider=\"get_available_attributes\",\n        title=\"Event Attributes\",\n        description=\"Select attributes based on selected activities and config\"\n    )\n\n    @staticmethod\n    def get_available_attributes(\n        inputs: dict,\n        log: OCEL,\n        config_file: Annotated[Resource, ResourceAnnotation(\n            label=\"Config File\",\n            description=\"External config used to filter attributes\"\n        )]\n    ) -&gt; list[str]:\n        ...\n        return attr_names\n\nclass ExamplePlugin(Plugin):\n\n    @plugin_method(\n        label=\"Select Event Attributes\",\n        description=\"Let users pick attributes dynamically\",\n    )\n    def select_attributes(\n        self,\n        log: OCEL,\n        config_file: Annotated[\n            Resource,\n            ResourceAnnotation(\n                label=\"Config File\",\n                description=\"External config to influence selection\"\n            )\n        ],\n        input: AttributeSelectionInput\n    ):\n        ...\n</code></pre> <p>This makes your input fields fully dynamic and context-aware \u2014 adjusting to the current OCEL log, user selections, and even external resources.</p>"},{"location":"plugins/plugin_class/#outputs","title":"Outputs","text":"<p>Plugin method outputs in Ocelescope are defined using standard Python type hints. Ocelescope inspects these type hints to understand what the method returns and automatically makes the results available for other plugin methods in the session.</p> <p>A plugin method can return:</p> <ul> <li>A single OCEL or Resource (e.g., <code>OCEL</code>, <code>PetriNet</code>)</li> <li>A list of OCELs or Resources (e.g., <code>list[OCEL]</code>, <code>list[PetriNet]</code>)</li> <li>A tuple containing any combination of the above (e.g., <code>tuple[OCEL, PetriNet, list[OCEL]]</code>)</li> </ul> <p>All returned OCELs and Resources are automatically saved in the session and can be used by future plugin methods.</p> Example: Returning a Single Resource<pre><code>def discover_model(self, ...) -&gt; PetriNet:\n    ...\n</code></pre> Example: Returning Multiple Results<pre><code>def analyze_and_export(self, ...) -&gt; tuple[PetriNet, OCEL, list[OCEL]]:\n    ...\n</code></pre> Example: Returning a List of Resources<pre><code>def generate_variants(self, ...) -&gt; list[PetriNet]:\n    ...\n</code></pre>"},{"location":"plugins/resource/","title":"Resources","text":"<p>Resources are the primary mechanism for defining inputs and outputs in Ocelescope plugins.</p> <p>A resource can represent almost anything \u2014 from process models to tabular datasets. Resources are automatically uploadable and downloadable, making them easy to share across plugin methods and even between different plugins.</p>"},{"location":"plugins/resource/#defining-a-resource","title":"Defining a Resource","text":"<p>To create a custom resource:</p> <ul> <li>Define a Python class that inherits from <code>Resource</code> (provided by the <code>ocelescope</code> package).  </li> <li>Resource classes can include any number of properties and methods required by your plugin.  </li> <li>Metadata such as <code>label</code> and <code>description</code> can be added to improve how the resource appears in the frontend.  </li> <li>Resources can be shared across plugins if they have the same class name and field definitions.</li> </ul> Example: Defining a Resource<pre><code>from ocelescope import Resource\n\nclass Example(Resource):\n    label = \"Example Resource\"\n    description = \"An example resource definition\"\n    property_a: str\n    property_b: list[int]\n</code></pre> <p>Resources Must Be JSON-Serializable</p> <p>For import and export to work, resources must be serializable and instantiable from their serialized form.</p> <p>Fields should use standard types such as <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>list</code>, or <code>dict</code>, or any custom subclass that is itself serializable.</p> <p>To verify that your resource is serializable, try creating an instance from its own serialized output:</p> <pre><code>Example(Example(property_a=\"Example String\", property_b=[1, 2, 3]).model_dump())\n</code></pre>"},{"location":"plugins/resource/#visualization","title":"Visualization","text":"<p>Visualizations in Ocelescope allow resources to render themselves in the frontend using predefined visualization types such as graphs, SVGs, and tables.</p> <p>To enable visualization for a resource, implement the <code>visualize()</code> method in your <code>Resource</code> subclass. This method should return one of the supported visualization objects described below.</p>"},{"location":"plugins/resource/#supported-visualization-types","title":"Supported Visualization Types","text":""},{"location":"plugins/resource/#graph","title":"Graph","text":"<p>A graph visualization model composed of nodes and directed edges. Commonly used for Petri nets, directly-follows graphs, and other graph-based models. Layout and rendering are powered by Graphviz.</p>"},{"location":"plugins/resource/#classes","title":"Classes","text":"<ul> <li><code>Graph</code></li> <li><code>GraphNode</code></li> <li><code>GraphEdge</code></li> <li><code>GraphvizLayoutConfig</code></li> </ul>"},{"location":"plugins/resource/#graphnode","title":"GraphNode","text":"<p>Defines a visual node in the graph.</p> Field Type Description <code>id</code> <code>str</code> Unique node ID (UUID string, auto-generated) <code>label</code> <code>str | None</code> Display label for the node <code>shape</code> <code>Literal[\"circle\", \"triangle\", \"rectangle\", \"diamond\", \"hexagon\"]</code> Node shape <code>width</code> <code>float | None</code> Node width in pixels <code>height</code> <code>float | None</code> Node height in pixels <code>color</code> <code>str | None</code> Fill color (hex or named color) <code>x</code> <code>float | None</code> X-coordinate after layout (auto-set) <code>y</code> <code>float | None</code> Y-coordinate after layout (auto-set) <code>border_color</code> <code>str | None</code> Border (stroke) color <code>label_pos</code> <code>Literal[\"top\", \"center\", \"bottom\"]</code> Label position relative to node (default: <code>\"bottom\"</code>) <code>rank</code> <code>Literal[\"source\", \"sink\"] | int | None</code> Optional rank constraint for layout (e.g., <code>\"source\"</code>, <code>\"sink\"</code>, or numeric level) <code>layout_attrs</code> <code>dict[str, str | int | float | bool] | None</code> Additional Graphviz attributes for this node"},{"location":"plugins/resource/#graphedge","title":"GraphEdge","text":"<p>Represents a directed connection between two nodes.</p> Field Type Description <code>id</code> <code>str</code> Unique edge ID (UUID string, auto-generated) <code>source</code> <code>str</code> Source node ID <code>target</code> <code>str</code> Target node ID <code>color</code> <code>str | None</code> Edge color <code>label</code> <code>str | None</code> Label text displayed along the edge <code>start_arrow</code> <code>EdgeArrow</code> Arrowhead at the start of the edge (default: <code>None</code>) <code>end_arrow</code> <code>EdgeArrow</code> Arrowhead at the end of the edge (default: <code>None</code>) <code>start_label</code> <code>str | None</code> Label near the source end <code>end_label</code> <code>str | None</code> Label near the target end <code>layout_attrs</code> <code>dict[str, str | int | float | bool] | None</code> Additional Graphviz attributes for this edge <code>annotation</code> <code>Visualization | None</code> Optional annotation attached to the edge"},{"location":"plugins/resource/#edgearrow","title":"EdgeArrow","text":"<p>Supported arrowhead styles:</p> <pre><code>\"triangle\" | \"circle-triangle\" | \"triangle-backcurve\" | \"tee\" | \"circle\" |\n\"chevron\" | \"triangle-tee\" | \"triangle-cross\" | \"vee\" | \"square\" | \"diamond\" | None\n</code></pre>"},{"location":"plugins/resource/#graphvizlayoutconfig","title":"GraphvizLayoutConfig","text":"<p>Specifies Graphviz layout engine and default attributes for rendering.</p> Field Type Description <code>engine</code> <code>GraphVizLayoutingEngine</code> Graphviz engine (<code>dot</code>, <code>neato</code>, <code>fdp</code>, <code>sfdp</code>, etc.) <code>graphAttrs</code> <code>dict[str, str | int | float | bool] | None</code> Global graph attributes (e.g., <code>rankdir</code>, <code>splines</code>, <code>size</code>) <code>nodeAttrs</code> <code>dict[str, str | int | float | bool] | None</code> Default attributes for all nodes (e.g., <code>shape</code>, <code>color</code>, <code>fontsize</code>) <code>edgeAttrs</code> <code>dict[str, str | int | float | bool] | None</code> Default attributes for all edges (e.g., <code>arrowsize</code>, <code>color</code>, <code>penwidth</code>)"},{"location":"plugins/resource/#graph_1","title":"Graph","text":"<p>Main graph visualization container.</p> Field Type Description <code>type</code> <code>Literal[\"graph\"]</code> Fixed type identifier <code>nodes</code> <code>list[GraphNode]</code> List of graph nodes <code>edges</code> <code>list[GraphEdge]</code> List of graph edges <code>layout_config</code> <code>GraphvizLayoutConfig</code> Graphviz layout configuration"},{"location":"plugins/resource/#example-usage","title":"Example Usage","text":"<pre><code>from ocelescope.visualization.graph import (\n    Graph, GraphNode, GraphEdge, GraphvizLayoutConfig\n)\n\ngraph = Graph(\n    nodes=[\n        GraphNode(label=\"Start\", shape=\"circle\", color=\"green\", rank=\"source\"),\n        GraphNode(label=\"End\", shape=\"rectangle\", color=\"red\", rank=\"sink\"),\n    ],\n    edges=[\n        GraphEdge(\n            source=\"n1\",\n            target=\"n2\",\n            label=\"Transition\",\n            color=\"gray\",\n            start_arrow=None,\n            end_arrow=\"triangle\"\n        )\n    ],\n    layout_config=GraphvizLayoutConfig(\n        engine=\"dot\",\n        graphAttrs={\n            \"rankdir\": \"LR\",  # Layout direction: Left to Right\n            \"nodesep\": 0.5,\n            \"ranksep\": 0.5\n        },\n        nodeAttrs={\n            \"shape\": \"circle\",\n            \"fontsize\": 12\n        },\n        edgeAttrs={\n            \"arrowsize\": 0.8,\n            \"color\": \"gray\"\n        }\n    )\n)\n</code></pre> <p>Graphviz automatically determines node coordinates (<code>x</code>, <code>y</code>) and dimensions (<code>width</code>, <code>height</code>) based on the chosen layout engine and attributes.</p>"},{"location":"plugins/resource/#svg","title":"SVG","text":"<p>Use raw SVG markup when a graph-based layout is not appropriate, or when you need full control over visuals.</p> <ul> <li>Class: <code>SVGVis</code></li> <li>Use case: Custom layouts, charts, icons, or any visualization expressible as SVG.</li> </ul> <p>Example</p> <pre><code>from ocelescope.visualization.default.svg import SVGVis\n\nclass MyRawSVGResource(Resource):\n    def visualize(self):\n        svg = \"\"\"\n        &lt;svg xmlns='http://www.w3.org/2000/svg' width='200' height='100'&gt;\n            &lt;circle cx='50' cy='50' r='40' fill='#ffcc00'/&gt;\n            &lt;text x='50' y='55' text-anchor='middle' font-size='14'&gt;Hello&lt;/text&gt;\n        &lt;/svg&gt;\n        \"\"\"\n        return SVGVis(type=\"svg\", svg=svg)\n</code></pre>"},{"location":"plugins/resource/#table","title":"Table","text":"<p>A structured table with typed columns and customizable rows. Ideal for datasets, summaries, or event logs.</p> <ul> <li>Class: <code>Table</code></li> <li>Column Class: <code>TableColumn</code></li> <li>Supported Column Types: <code>string</code>, <code>number</code>, <code>boolean</code>, <code>date</code>, <code>datetime</code></li> </ul> <pre><code>from ocelescope.visualization.default.table import Table, TableColumn\n\nclass MyTableResource(Resource):\n    def visualize(self):\n        return Table(\n            columns=[\n                TableColumn(id=\"name\", label=\"Name\", data_type=\"string\"),\n                TableColumn(id=\"age\", label=\"Age\", data_type=\"number\"),\n                TableColumn(id=\"member\", label=\"Is Member\", data_type=\"boolean\"),\n                TableColumn(id=\"joined\", label=\"Join Date\", data_type=\"date\")\n            ],\n            rows=[\n                {\"name\": \"Alice\", \"age\": 30, \"member\": True, \"joined\": \"2022-01-15\"},\n                {\"name\": \"Bob\", \"age\": 25, \"member\": False, \"joined\": \"2023-06-10\"},\n                {\"name\": \"Charlie\", \"age\": 40, \"member\": True, \"joined\": \"2021-09-20\"}\n            ]\n        )\n</code></pre> <p>The table supports sorting, hiding, and formatting options for each column.</p> <p>For advanced use cases, you can contribute your own visualization types to the Ocelescope framework</p>"},{"location":"plugins/resource/#dot","title":"Dot","text":"<p>A raw Graphviz DOT visualization, preserving the full DOT source string. Useful when you want direct control over Graphviz rendering or need to reuse an existing DOT description.</p> <ul> <li>Class: <code>DotVis</code></li> <li>Layout: Explicitly set by Graphviz via a chosen layout engine (<code>dot</code>, <code>neato</code>, <code>fdp</code>, etc.)</li> </ul>"},{"location":"plugins/resource/#dotvis","title":"DotVis","text":"Field Type Description <code>type</code> <code>Literal[\"dot\"]</code> Identifies the visualization type as DOT <code>dot_str</code> <code>str</code> The raw DOT source string (as produced by <code>graphviz.Digraph</code> or <code>Graph</code>) <code>layout_engine</code> <code>GraphVizLayoutingEngine</code> The Graphviz engine used (<code>dot</code>, <code>neato</code>, <code>fdp</code>, <code>sfdp</code>, <code>circo</code>, etc.)"},{"location":"plugins/resource/#supported-layout-engines","title":"Supported Layout Engines","text":"Engine Description <code>dot</code> Hierarchical layouts, suited for layered graphs and flowcharts <code>neato</code> Spring-model layouts, good for undirected graphs <code>fdp</code> Force-directed placement, similar to <code>neato</code> <code>sfdp</code> Scalable force-directed placement for large graphs <code>circo</code> Circular layouts <code>twopi</code> Radial layouts (nodes placed in concentric circles) <code>osage</code> Clustered layouts <code>patchwork</code> Treemap-style layouts <code>nop</code>, <code>nop2</code> No-op layout engines (use raw input positions if given)"},{"location":"plugins/resource/#constructing-from-graphviz","title":"Constructing from Graphviz","text":"<p>Use <code>.from_graphviz()</code> to convert an existing <code>graphviz.Digraph</code> or <code>graphviz.Graph</code> object into a <code>DotVis</code>.</p> <pre><code>from graphviz import Digraph\nfrom ocelescope.visualization.default.dot import DotVis\n\nclass MyDotResource(Resource):\n    def visualize(self):\n        dot = Digraph()\n        dot.node(\"A\", \"Start\")\n        dot.node(\"B\", \"End\")\n        dot.edge(\"A\", \"B\")\n\n        return DotVis.from_graphviz(\n            graph=dot,\n            layout_engine=\"dot\"   # or \"neato\", \"circo\", etc.\n        )\n</code></pre> <p>The resulting <code>DotVis</code> object carries both the DOT source (<code>dot_str</code>) and the layout engine specification, allowing full control over Graphviz rendering.</p>"},{"location":"plugins/tutorial/","title":"Tutorial: OCEL Graph","text":"<p>This tutorial provides a general example for developing an Ocelescope plugin from scratch.</p> <p>In this tutorial, we will build an OCEL Graph plugin inspired by the OCELGraph feature of the OCPQ tool.</p> <p>An OCEL graph visualizes how objects and events are related to each other. The plugin lets you choose an object or event ID as the starting point (the root), and then builds a spanning tree from that root based on the connected relationships in the ocel. You can also set how far the graph should expand from the starting point.</p> The input of the OCEL Graph The output of the OCEL Graph <p>Try out OCELGraph</p> <p>You can explore the source code in the repository below, or download the plugin and try it out yourself.</p> <p> Download Source </p> <p>Requirements</p> <p>This project requires Python 3.12 to be installed on your system. For easy and reproducible package management, we recommend using uv.</p>"},{"location":"plugins/tutorial/#step-1-setup","title":"Step 1: Setup","text":"<p>To get started, we recommend using the official template for plugin development. You can quickly generate a new project using uvx, a tool from the uv project that allows you to run project generators like cookiecutter. To use the template with uvx, run:</p> <pre><code>uvx cookiecutter gh:rwth-pads/ocelescope --directory template\n</code></pre> <p>Alternatively, you can clone the template repository directly:</p> <pre><code>git clone git@github.com:Grkmr/Ocelescope-Template.git\n</code></pre> <p>Once you have your project set up, install all dependencies with:</p> <pre><code>uv sync\n</code></pre> <p>If you prefer not to use uv or uvx, you can also use other Python package managers such as pip, pip-tools, or poetry to install dependencies. Simply reference the requirements.txt or pyproject.toml file included in the template. For example, with pip you can run:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>If you used the template, you should already have a plugin set up with the necessary metadata, and your project structure should look like the following:</p> <pre><code>ocel-graph/\n\u251c\u2500\u2500 scripts/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 ocel_graph/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 plugin.py\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 requierements.txt\n</code></pre> <p>The template is designed as a minimal example, with the entire plugin logic contained in the <code>plugin.py</code> file. This makes it easy to get started and see how everything works in one place.</p> <p>We highly recommend using Git for version control. If you haven\u2019t already initialized a Git repository in your project, you can do so now with:</p> <pre><code>git init\n</code></pre> <p>If you are using Git, the Cookiecutter template also sets up a pre-commit hook that will automatically format your code before each commit. To activate this hook, simply run:</p> <pre><code>precommit install \n</code></pre> <p>or if you are using uv:</p> <pre><code>uvx precommit install\n</code></pre>"},{"location":"plugins/tutorial/#step-2-writing-the-plugin","title":"Step 2: Writing the Plugin","text":""},{"location":"plugins/tutorial/#writing-plugin-metadata","title":"Writing Plugin Metadata","text":"<p>An Ocelescope plugin is defined by its Plugin Class. Let's start by adding some metadata to it.</p> <p>If you created your project using the Cookiecutter template, this should already be set up for you. If not, open <code>plugin.py</code>, find the plugin class, and rename the class and its metadata to something like the following:</p> <pre><code>class OcelGraphDiscovery(Plugin):\n    label = \"OCEL Graph\"\n    description = \"Generate your own OCEL Graph\"\n    version = \"0.1.0\"\n    ...\n</code></pre> <ul> <li>The class name (OcelGraphDiscovery) is the unique name of your plugin and is used to distinguish it from other plugins.</li> <li>The label is what will be shown in the UI.</li> <li>The description briefly explains what your plugin does.</li> <li>The version field lets you update your plugin with new features or bug fixes over time.</li> </ul>"},{"location":"plugins/tutorial/#adding-a-plugin-method","title":"Adding a Plugin Method","text":"<p>Now let\u2019s start writing the actual script that processes an OCEL and generates an OCEL Graph.</p> <p>Add a new method to your plugin class called <code>mine_ocel_graph</code>. Every plugin method should be decorated with <code>@plugin_method</code>, where you can specify a label and a description. These will be displayed in the frontend interface.</p> <pre><code>class OcelGraphDiscovery(Plugin):\n    @plugin_method(label=\"Mine OCEL Graph\", description=\"Mines a ocel graph\")\n    def mine_ocel_graph(\n        self,\n    ):\n        pass\n</code></pre>"},{"location":"plugins/tutorial/#defining-plugin-inputs","title":"Defining Plugin Inputs","text":"<p>When writing a plugin method, it\u2019s always important to think beforehand about its inputs and outputs. For our OCEL Graph plugin, we need the following inputs:</p> <ul> <li>ocel: The OCEL log to analyze.</li> <li>entity_id: An identifier for the root of the graph. This can be either an object ID or an event ID from the OCEL log.</li> <li>max_depth: The maximum depth to which the graph should be explored from the root entity.</li> <li>max_neighbours: The maximum number of neighbours to include at each step, to prevent the graph from growing too large and becoming unmanageable.</li> </ul> <p>As an output, our method will return an OCEL graph. Since plugin methods in Ocelescope can only return either OCEL logs or resources, the OCEL graph must be implemented as a resource.</p> <pre><code>flowchart LR\n    subgraph inputs [Inputs]\n    OCEL[\"OCEL Log\"]\n    EntityID[\"Entity ID&lt;br/&gt;(object or event ID)\"]\n    MaxDepth[\"Max Depth\"]\n    MaxNeighbours[\"Max Neighbours\"]\n    end\n\n    Method[\"mine_ocel_graph()\"]\n\n    subgraph outputs [Outputs]\n    OCELGraph[\"OCEL Graph&lt;br/&gt;(Resource)\"]\n    end\n\n\n    inputs --&gt; Method\n    Method --&gt; outputs\n\n    EntityID -. references .-&gt; OCEL</code></pre>"},{"location":"plugins/tutorial/#adding-an-ocel-input","title":"Adding an OCEL Input","text":"<p>Since our goal is to create an OCEL Graph, we need to have an OCEL log as one of the method inputs. This can be done by simply adding it as a parameter to the mine_ocel_graph method:</p> <pre><code>from ocelescope import OCEL\n...\n  @plugin_method(label=\"Mine OCEL Graph\", description=\"Mines a ocel graph\")\n  def mine_ocel_graph(self, ocel: OCEL):\n      pass\n</code></pre> <p>To make it easier for users in the frontend, you can give this input a prettier name and a helpful description. You do this by annotating the parameter with the OCELAnnotation class:</p> <pre><code>def mine_ocel_graph(\n    self,\n    ocel: Annotated[\n        OCEL,\n        OCELAnnotation(\n            label=\"Event Log\",\n            description=\"The log from which the OCEL graph should be mined\",\n        ),\n    ],\n):\n    pass\n</code></pre> <p>Now, in the frontend, users will see a friendly label and description when selecting the OCEL log input for your plugin.</p>"},{"location":"plugins/tutorial/#adding-a-configuration-input","title":"Adding a Configuration Input","text":"<p>To make the OCEL Graph plugin interactive, we\u2019ll define a configuration input class. This allows users to add configuration parameters for the plugin method..</p> <p>First, either add a new input class or rewrite the existing input class in your template. Rename the class to <code>OCELGraphInput</code> to match your plugin.</p> <pre><code>from ocelescope import PluginInput\n\nclass OCELGraphInput(PluginInput, frozen=True):\n    pass\n</code></pre> <p>Why frozen=True is important</p> <p>Always set <code>frozen=True</code> when inheriting from <code>PluginInput</code>. This makes your configuration input immutable, which is required by Ocelescope for proper validation and stability.</p> <p>Now, extend your <code>OCELGraphInput</code> class to include configuration parameters for the maximum depth of the OCEL graph and the maximum number of neighbours per node.</p> <p>Use Pydantic\u2019s <code>Field</code> to set titles, descriptions, defaults, and constraints for these integer values.</p> <pre><code>from pydantic import Field\n\nclass OCELGraphInput(PluginInput, frozen=True):\n    depth: int = Field(\n        title=\"OCEL Graph Depth\",\n        description=\"The maximum depth of the OCEL graph\",\n        default=3,\n        gt=0,\n        le=10\n    )\n    max_neighbours: int = Field(\n        title=\"Maximum Neighbours\",\n        description=\"The maximum amount of neighbours a node can have\",\n        default=5,\n        gt=0\n    )\n</code></pre> <p>To let users select the root entity of the OCEL graph, define two classes:</p> <ul> <li><code>ObjectRoot</code> for selecting an object by its ID  </li> <li><code>EventRoot</code> for selecting an event by its ID  </li> </ul> <p>Each class uses the <code>OCEL_FIELD</code> helper to link the field to the selected OCEL log, enabling autocomplete and validation in the UI.</p> <pre><code>from pydantic import BaseModel\nfrom ocelescope import OCEL_FIELD\n\nclass ObjectRoot(BaseModel):\n    class Config:\n        title = \"Object\"\n\n    object_id: str = OCEL_FIELD(\n        field_type=\"object_id\",\n        title=\"Object Id\",\n        ocel_id=\"ocel\",\n        description=\"The ID of the Object which is the root of the OCEL Graph\",\n    )\n\nclass EventRoot(BaseModel):\n    class Config:\n        title = \"Event\"\n\n    event_id: str = OCEL_FIELD(\n        field_type=\"event_id\",\n        title=\"Event Id\",\n        ocel_id=\"ocel\",\n        description=\"The ID of the Event which is the root of the OCEL Graph\",\n    )\n</code></pre> <p>These classes are then combined in your main input class using a union type (<code>ObjectRoot | EventRoot</code>):</p> <pre><code>class OCELGraphInput(PluginInput, frozen=True):\n    root: ObjectRoot | EventRoot\n    ...\n</code></pre> <p>Why use a union? The union type allows users to select either an object or an event as the root entity of the OCEL graph, but not both at the same time. This creates a flexible input in the UI, where the user first chooses the entity type (object or event), and then provides the appropriate ID.</p> <p>The <code>Config</code> class provides a user-friendly label for each option in the frontend. The <code>OCEL_FIELD</code> helper ensures that the field will autocomplete with available IDs from the OCEL log chosen by the user.</p> <p>Important</p> <p>The <code>ocel_id</code> argument in <code>OCEL_FIELD</code> must exactly match the name of the OCEL parameter in your plugin method (for example, <code>ocel</code> in <code>def mine_ocel_graph(self, ocel: OCEL, ...)</code>). This ensures that the field is correctly linked to the user-selected OCEL log and will display the appropriate dropdown/autocomplete values.</p> <p>The final code for your configuration input class looks like this:</p> <pre><code>from ocelescope import OCEL_FIELD, PluginInput\nfrom pydantic import BaseModel, Field\n\nclass ObjectRoot(BaseModel):\n    class Config:\n        title = \"Object\"\n\n    object_id: str = OCEL_FIELD(\n        field_type=\"object_id\",\n        title=\"Object Id\",\n        ocel_id=\"ocel\",\n        description=\"The ID of the Object which is the root of the OcelGraph\",\n    )\n\nclass EventRoot(BaseModel):\n    class Config:\n        title = \"Event\"\n\n    event_id: str = OCEL_FIELD(\n        field_type=\"event_id\",\n        title=\"Event Id\",\n        ocel_id=\"ocel\",\n        description=\"The ID of the Event which is the root of the OcelGraph\",\n    )\n\nclass OCELGraphInput(PluginInput, frozen=True):\n    root: ObjectRoot | EventRoot\n    depth: int = Field(\n        title=\"OCEL Graph Depth\",\n        description=\"The maximum depth of the ocel graph\",\n        default=3,\n        gt=0,\n        le=10\n    )\n    max_neighbours: int = Field(\n        title=\"Maximum Neighbours\",\n        description=\"The maximum amount of neighbours a node can have\",\n        gt=0,\n        default=5\n    )\n</code></pre> <p>This code creates the following input form in the frontend:</p> <p></p>"},{"location":"plugins/tutorial/#defining-a-resource","title":"Defining a Resource","text":"<p>We want to define a custom output\u2014an OCEL Graph\u2014which in Ocelescope is done by creating a Python class that inherits from the <code>Resource</code> class.</p> <pre><code>from ocelescope import Resource\nfrom ocelescope.visualization import Graph, GraphEdge, GraphvizLayoutConfig\nfrom ocelescope.visualization.default.graph import GraphNode\nfrom ocelescope.visualization.util.color import generate_color_map\nfrom pydantic import BaseModel\n\nclass EventNode(BaseModel):\n    id: str\n    activity_type: str\n\nclass ObjectNode(BaseModel):\n    id: str\n    object_type: str\n\nclass Relation(BaseModel):\n    qualifier: str\n\nclass O2ORelation(Relation):\n    source: str\n    target: str\n\nclass E2ORelation(Relation):\n    event_id: str\n    object_id: str\n    object_type: str\n\nclass OCELGraph(Resource):\n    label = \"Ocel Graph\"\n    description = \"A Ocel graph\"\n\n    events: list[EventNode] = []\n    objects: list[ObjectNode] = []\n    e2o_relations: list[E2ORelation] = []\n    o2o_relations: list[O2ORelation] = []\n\n    @property\n    def event_ids(self) -&gt; list[str]:\n        return [event.id for event in self.events]\n\n    @property\n    def object_ids(self) -&gt; list[str]:\n        return [object.id for object in self.objects]\n</code></pre> <p>Important</p> <p>All subclasses used as properties in your resource (such as <code>EventNode</code>, <code>ObjectNode</code>, <code>Relation</code>, <code>O2ORelation</code>, and <code>E2ORelation</code>) should inherit from Pydantic\u2019s <code>BaseModel</code>. This ensures that your data structures are compatible with Ocelescope\u2019s validation and serialization.</p> <p>You can also add a label and a description to your resource class, which helps the frontend display more user-friendly labels.</p> <p>A resource can include any property that can be serialized to JSON\u2014such as lists, strings, numbers, or other <code>BaseModel</code> classes.</p> <p>You can also add any number of functions to work with the resource. For example, here\u2019s how to get all event and object IDs inside the resource:</p> <pre><code>    @property\n    def event_ids(self) -&gt; list[str]:\n        return [event.id for event in self.events]\n\n    @property\n    def object_ids(self) -&gt; list[str]:\n        return [object.id for object in self.objects]\n</code></pre> <p>To tell Ocelescope that your method returns your <code>OCELGraph</code>, add it as a type hint in your plugin method:</p> <pre><code>class OcelGraphDiscovery(Plugin):\n    ...\n    @plugin_method(label=\"Mine OCEL Graph\", description=\"Mines an OCEL Graph\")\n    def mine_ocel_graph(...) -&gt; OCELGraph:\n        ...\n</code></pre>"},{"location":"plugins/tutorial/#visualization","title":"Visualization","text":"<p>At this point, our <code>OCELGraph</code> class can already be used as a resource and returned as an output from your plugin method. However, by default, it is just a data structure without any built-in visualization.</p> <p>To enable visualization in the Ocelescope frontend, you can extend your resource class by adding a <code>visualize</code> method. A visualization function is a class method that returns a predefined visualization object (such as a <code>Graph</code>), and should include a type hint for clarity.</p> <p>For example, you can add the following <code>visualize</code> method to your <code>OCELGraph</code> class:</p> <pre><code>from ocelescope import Resource\nfrom ocelescope.visualization import Graph, GraphEdge, GraphvizLayoutConfig\nfrom ocelescope.visualization.default.graph import GraphNode\nfrom ocelescope.visualization.util.color import generate_color_map\n\n...\n\nclass OCELGraph(Resource):\n    ...\n    def visualize(self) -&gt; Graph:\n        color_map = generate_color_map(list(set([object.object_type for object in self.objects])))\n\n        object_nodes = [\n            GraphNode(\n                id=object_node.id, shape=\"rectangle\", label=object_node.id, color=color_map[object_node.object_type]\n            )\n            for object_node in self.objects\n        ]\n\n        event_nodes = [GraphNode(id=event.id, shape=\"rectangle\", label=event.id) for event in self.events]\n\n        e2o_edges = [\n            GraphEdge(\n                source=edge.event_id,\n                target=edge.object_id,\n                arrows=(None, None),\n                color=color_map[edge.object_type],\n                label=edge.qualifier,\n            )\n            for edge in self.e2o_relations\n        ]\n        o2o_edges = [\n            GraphEdge(source=edge.source, target=edge.target, arrows=(None, None), label=edge.qualifier)\n            for edge in self.o2o_relations\n        ]\n\n        return Graph(\n            type=\"graph\",\n            nodes=object_nodes + event_nodes,\n            edges=e2o_edges + o2o_edges,\n            layout_config=GraphvizLayoutConfig(engine=\"neato\", graphAttrs={\"overlap\": \"prism\"}),\n        )\n</code></pre> <p>With this method, your resource will not only provide the OCEL graph data, but also a built-in visualization for the Ocelescope frontend to display.</p> <p></p>"},{"location":"plugins/tutorial/#implementing-the-plugin-method","title":"Implementing the Plugin Method","text":"<p>Now let's implement the method which transforms our input (the OCEL and configuration) and returns our resource. For the sake of this tutorial, we won\u2019t discuss the implementation details. Instead, we\u2019ll add the implementation in a utility file to keep the plugin method itself clean and readable.</p> <p>For example, in your utility file (e.g., <code>util.py</code>):</p> Show mine_ocel_graph Implementation util.py<pre><code>from typing import cast\n\nimport pandas as pd\nfrom ocelescope import OCEL\n\nfrom .inputs.ocelGraph import EventRoot, OCELGraphInput\nfrom .resources.ocelGraph import E2ORelation, EventNode, O2ORelation, ObjectNode, OCELGraph\n\n# Generic function to count neighbours (events or objects)\n\ndef group_relation_entity(\n    df: pd.DataFrame,\n    entity_ids: list[str],\n    id_column: str,\n    type_column: str,\n    target_id_column: str,\n):\n    \"\"\"\n    Count how many 'target' entities are linked to each entity (event or object).\n\n    Returns:\n        DataFrame with columns: id, type, count\n    \"\"\"\n    return (\n        df[df[id_column].isin(entity_ids)]\n        .groupby([id_column, type_column])[target_id_column]\n        .size()\n        .reset_index()\n        .rename(columns={id_column: \"id\", type_column: \"type\", target_id_column: \"count\"})\n    )\n\n\ndef mine_ocel_graph(ocel: OCEL, input: OCELGraphInput):\n    graph = OCELGraph()\n\n    events_to_visit = []\n    objects_to_visit = []\n\n    if isinstance(input.root, EventRoot):\n        root_id = input.root.event_id\n        root = ocel.events[ocel.events[ocel.ocel.event_id_column] == input.root.event_id].iloc[0]\n        events_to_visit.append(EventNode(id=input.root.event_id, activity_type=root[ocel.ocel.event_activity]))\n    else:\n        root_id = input.root.object_id\n        root = ocel.objects[ocel.objects[ocel.ocel.object_id_column] == input.root.object_id].iloc[0]\n        objects_to_visit.append(ObjectNode(id=input.root.object_id, object_type=root[ocel.ocel.object_type_column]))\n\n    for _ in range(input.depth):\n        # Get current frontier IDs\n        event_ids_to_visit = [event.id for event in events_to_visit]\n        object_ids_to_visit = [obj.id for obj in objects_to_visit]\n\n        # Get event-object relations using XOR and not already in the graph\n        relations: pd.DataFrame = cast(\n            pd.DataFrame,\n            ocel.relations[\n                (\n                    (ocel.relations[ocel.ocel.event_id_column].isin(event_ids_to_visit))\n                    ^ (ocel.relations[ocel.ocel.object_id_column].isin(object_ids_to_visit))\n                )\n                &amp; ~(ocel.relations[ocel.ocel.event_id_column].isin(graph.event_ids))\n                &amp; ~(ocel.relations[ocel.ocel.object_id_column].isin(graph.object_ids))\n            ],\n        )\n\n        # Count object neighbors per event\n        events = group_relation_entity(\n            df=relations,\n            entity_ids=event_ids_to_visit,\n            id_column=ocel.ocel.event_id_column,\n            type_column=ocel.ocel.event_activity,\n            target_id_column=ocel.ocel.object_id_column,\n        )\n\n        # Count event neighbors per object\n        e2o_objects = group_relation_entity(\n            df=relations,\n            entity_ids=object_ids_to_visit,\n            id_column=ocel.ocel.object_id_column,\n            type_column=ocel.ocel.object_type_column,\n            target_id_column=ocel.ocel.event_id_column,\n        )\n\n        # Get object-object (o2o) relations using XOR\n        o2o = cast(\n            pd.DataFrame,\n            ocel.o2o[\n                (\n                    (ocel.o2o[\"ocel:oid_1\"].isin(object_ids_to_visit))\n                    ^ (ocel.o2o[\"ocel:oid_2\"].isin(object_ids_to_visit))\n                )\n                &amp; ~(ocel.o2o[\"ocel:oid_1\"].isin(graph.object_ids))\n                &amp; ~(ocel.o2o[\"ocel:oid_2\"].isin(graph.object_ids))\n            ],\n        )\n\n        # Normalize and mirror o2o (treat as undirected)\n        o2o = o2o.rename(\n            columns={\"ocel:oid_1\": \"id\", \"ocel:type_1\": \"type\", \"ocel:oid_2\": \"target_id\", \"ocel:type_2\": \"target_type\"}\n        )\n\n        mirrored = o2o.rename(\n            columns={\"target_id\": \"id\", \"target_type\": \"type\", \"id\": \"target_id\", \"type\": \"target_type\"}\n        )\n\n        mirrored_o2o = pd.concat([o2o, mirrored], ignore_index=True).rename(columns={\"ocel:qualifier\": \"qualifier\"})\n\n        # Count o2o neighbours for each object\n        o2o_objects = group_relation_entity(\n            df=mirrored_o2o,\n            entity_ids=object_ids_to_visit,\n            id_column=\"id\",\n            type_column=\"type\",\n            target_id_column=\"target_id\",\n        )\n\n        # Combine object neighbour counts\n        objects = (\n            pd.concat([o2o_objects, e2o_objects], ignore_index=True)\n            .groupby([\"id\", \"type\"], as_index=False)[\"count\"]\n            .sum()\n        )\n\n        # Update graph with this layer\n        graph.objects = graph.objects + objects_to_visit\n        graph.events = graph.events + events_to_visit\n\n        # Prepare for next layer\n        events_to_visit = []\n        objects_to_visit = []\n\n        object_id_with_neighbours = [\n            row[\"id\"] for _, row in objects.iterrows() if row[\"count\"] &lt;= input.max_neighbours or row[\"id\"] == root_id\n        ]\n        event_id_with_neighbours = [\n            row[\"id\"] for _, row in events.iterrows() if row[\"count\"] &lt;= input.max_neighbours or row[\"id\"] == root_id\n        ]\n\n        # Add o2o relations to graph and queue new objects\n        for _, row in (\n            cast(pd.DataFrame, mirrored_o2o[mirrored_o2o[\"id\"].isin(object_id_with_neighbours)])\n            .drop_duplicates(subset=[\"target_id\"], keep=\"first\")\n            .iterrows()\n        ):\n            graph.o2o_relations.append(\n                O2ORelation(source=str(row[\"id\"]), target=str(row[\"target_id\"]), qualifier=str(row[\"qualifier\"]))\n            )\n            objects_to_visit.append(ObjectNode(id=str(row[\"target_id\"]), object_type=str(row[\"target_type\"])))\n\n        # Add e2o relations (object \u2192 event)\n        for _, row in (\n            cast(pd.DataFrame, relations[relations[\"ocel:oid\"].isin(object_id_with_neighbours)])\n            .drop_duplicates(subset=[\"ocel:eid\"], keep=\"first\")\n            .iterrows()\n        ):\n            graph.e2o_relations.append(\n                E2ORelation(\n                    event_id=str(row[\"ocel:eid\"]),\n                    object_id=str(row[\"ocel:oid\"]),\n                    qualifier=str(row[\"ocel:qualifier\"]),\n                    object_type=str(row[\"ocel:type\"]),\n                )\n            )\n            events_to_visit.append(EventNode(id=str(row[\"ocel:eid\"]), activity_type=str(row[\"ocel:activity\"])))\n\n        # Add e2o relations (event \u2192 object)\n        for _, row in (\n            cast(\n                pd.DataFrame,\n                relations[\n                    relations[\"ocel:eid\"].isin(event_id_with_neighbours)\n                    &amp; ~relations[\"ocel:oid\"].isin([obj.id for obj in objects_to_visit])\n                ],\n            )\n            .drop_duplicates(subset=[\"ocel:oid\"], keep=\"first\")\n            .iterrows()\n        ):\n            graph.e2o_relations.append(\n                E2ORelation(\n                    event_id=str(row[\"ocel:eid\"]),\n                    object_id=str(row[\"ocel:oid\"]),\n                    qualifier=str(row[\"ocel:qualifier\"]),\n                    object_type=str(row[\"ocel:type\"]),\n                )\n            )\n            objects_to_visit.append(ObjectNode(id=str(row[\"ocel:oid\"]), object_type=str(row[\"ocel:type\"])))\n\n    graph.objects = graph.objects + objects_to_visit\n    graph.events = graph.events + events_to_visit\n\n    return graph\n</code></pre> <p>In your plugin class, simply import and call this function:</p> <pre><code>from .util import mine_ocel_graph\n\nclass OcelGraphDiscovery(Plugin):\n    ...\n    @plugin_method(label=\"Mine OCEL Graph\", description=\"Mines a OCEL Graph\")\n    def mine_ocel_graph(self, ocel: OCEL, input: OCELGraphInput) -&gt; OCELGraph:\n        return mine_ocel_graph(ocel, input)\n</code></pre> <p>Warning</p> <p>Currently, Ocelescope plugins only support relative imports. This means you must ensure all imports inside your plugin use relative paths.</p> <pre><code># \u2705 Correct (relative import)\nfrom .util import some_function\n\n# \u274c Incorrect (absolute import)\nfrom ocel_graph.util import some_function\n</code></pre>"},{"location":"plugins/tutorial/#step-3-build-plugin","title":"Step 3: Build Plugin","text":"<p>Before your plugin can be built, make sure that the top-level <code>__init__.py</code> properly exposes your plugin class:</p> __init__.py<pre><code>from .plugin import OcelGraphDiscovery\n\n__all__ = [\n    \"OcelGraphDiscovery\",\n]\n</code></pre> <p>In ocelescope plugins are basically just the packages zipped so in our case:</p> <pre><code>ocel_graph/\n  \u251c\u2500\u2500 __init__.py\n  \u2514\u2500\u2500 plugin.py\n</code></pre> <p>You can create the zip manually, or use the provided build script from the Ocelescope template by running at the project root:</p> <pre><code>python scripts/build_plugin.py\n</code></pre> <p>Or if you are using uv:</p> <pre><code>uv run python scripts/build_plugin.py\n</code></pre> <p>The build script also checks for any absolute imports you may have missed and will raise an error if it finds them. After running the build, your plugin package will be created in the dist/ folder.</p>"},{"location":"references/core/","title":"Core","text":""},{"location":"references/core/#ocelescope.ocel.core.ocel.OCEL","title":"OCEL","text":"<p>High-level wrapper for an OCEL 2.0 event log.</p> <p>This class provides a structured access layer over a PM4PY OCEL instance. It exposes convenient managers for objects, events, E2O relations, O2O relations, and extensions. It also supports reading, writing, and filtering OCEL logs.</p> <p>Attributes:</p> Name Type Description <code>ocel</code> <code>OCEL</code> <p>The underlying PM4PY OCEL object containing the raw OCEL data (events, objects, relations).</p> <code>meta</code> <code>OCELMeta</code> <p>Metadata associated with this OCEL instance, including file path, unique ID, and any additional user-defined information.</p> <code>extensions</code> <code>ExtensionManager</code> <p>Manages all loaded OCEL extensions and handles exporting of extension data.</p> <code>objects</code> <code>ObjectsManager</code> <p>Provides structured access to all object-related information such as types, attributes, and object tables.</p> <code>events</code> <code>EventsManager</code> <p>Provides structured access to event-level information such as activities, event attributes, and event tables.</p> <code>e2o</code> <code>E2OManager</code> <p>Manages event-to-object relations, including typed relations and qualifier-based summaries.</p> <code>o2o</code> <code>O2OManager</code> <p>Manages object-to-object relations, providing typed lookups and relation-count summaries.</p> Returned by: <ul> <li> References OCEL Core <code></code>\u00a0OCEL <code></code>\u00a0filter </li> <li> References OCEL Core <code></code>\u00a0OCEL <code></code>\u00a0read </li> </ul> Source code in <code>src/ocelescope/src/ocelescope/ocel/core/ocel.py</code> <pre><code>class OCEL:\n    \"\"\"\n    High-level wrapper for an OCEL 2.0 event log.\n\n    This class provides a structured access layer over a PM4PY OCEL instance.\n    It exposes convenient managers for objects, events, E2O relations, O2O\n    relations, and extensions. It also supports reading, writing, and\n    filtering OCEL logs.\n\n    Attributes:\n        ocel (PM4PYOCEL):\n            The underlying PM4PY OCEL object containing the raw OCEL data\n            (events, objects, relations).\n        meta (OCELMeta):\n            Metadata associated with this OCEL instance, including file path,\n            unique ID, and any additional user-defined information.\n        extensions (ExtensionManager):\n            Manages all loaded OCEL extensions and handles exporting of\n            extension data.\n        objects (ObjectsManager):\n            Provides structured access to all object-related information such\n            as types, attributes, and object tables.\n        events (EventsManager):\n            Provides structured access to event-level information such as\n            activities, event attributes, and event tables.\n        e2o (E2OManager):\n            Manages event-to-object relations, including typed relations and\n            qualifier-based summaries.\n        o2o (O2OManager):\n            Manages object-to-object relations, providing typed lookups and\n            relation-count summaries.\n    \"\"\"\n\n    def __init__(self, ocel: PM4PYOCEL, meta: OCELMeta | None = None):\n        self.ocel = ocel\n        self.meta = meta or OCELMeta()\n        self.extensions = ExtensionManager(self)\n        self.objects = ObjectsManager(self)\n        self.events = EventsManager(self)\n        self.e2o = E2OManager(self)\n        self.o2o = O2OManager(self)\n\n    def filter(self, pipeline: list[BaseFilter]) -&gt; OCEL:\n        \"\"\"\n        Apply a sequence of filters to this OCEL instance.\n\n        Filters are executed in sequence, and their boolean masks are merged\n        to produce a refined subset of events and objects. A new OCEL instance\n        is returned containing only the items that satisfy all filters.\n\n        Args:\n            pipeline (list[BaseFilter]):\n                A list of filter objects, each implementing a ``filter()`` method\n                that returns a ``FilterResult`` mask.\n\n        Returns:\n            OCEL: A new OCEL instance representing the filtered view of the log.\n        \"\"\"\n        from ocelescope.ocel.filter.engine import apply_filters\n\n        return apply_filters(ocel=self, filters=pipeline)\n\n    @staticmethod\n    def read(path: str | Path, meta: dict[str, Any] = {}) -&gt; OCEL:\n        \"\"\"\n        Read an OCEL file (.jsonocel, .xmlocel, or .sqlite) from disk.\n\n        Automatically detects the file format based on extension and loads the\n        OCEL into a structured wrapper.\n\n        Args:\n            path (str | Path):\n                Path to the OCEL file on disk.\n            meta (dict[str, Any], optional):\n                Additional metadata to attach to the OCELMeta container.\n\n        Returns:\n            OCEL: A fully constructed OCEL wrapper instance.\n        \"\"\"\n\n        path = Path(path)\n\n        with warnings.catch_warnings(record=True):\n            match path.suffix:\n                case \".sqlite\":\n                    pm4py_ocel = pm4py.read.read_ocel2_sqlite(str(path))\n                case \".xmlocel\":\n                    pm4py_ocel = pm4py.read.read_ocel2_xml(str(path))\n                case \".jsonocel\":\n                    pm4py_ocel = pm4py.read.read_ocel2_json(str(path))\n                case _:\n                    raise ValueError(f\"Unsupported extension: {path.suffix}\")\n\n        return OCEL(ocel=pm4py_ocel, meta=OCELMeta(path=path, extra=meta))\n\n    def write(self, path: str | Path):\n        \"\"\"\n        Write the OCEL log and all registered extensions to disk.\n\n        The output format is inferred from the file extension. Supported file\n        types are:\n            - .jsonocel\n            - .xmlocel\n            - .sqlite\n\n        Args:\n            path (str | Path):\n                Destination file path.\n\n        Raises:\n            ValueError: If the file extension is not supported.\n        \"\"\"\n        path = Path(path)\n\n        match path.suffix:\n            case \".xmlocel\":\n                pm4py.write_ocel2_xml(self.ocel, str(path))\n            case \".jsonocel\":\n                pm4py.write_ocel2_json(self.ocel, str(path))\n            case \".sqlite\":\n                pm4py.write_ocel2_sqlite(self.ocel, str(path))\n            case _:\n                raise ValueError(f\"Unsupported extension: {path.suffix}\")\n\n        self.extensions.export_all(path)\n\n    def __deepcopy__(self, memo: dict[int, Any]):\n        # TODO revisit this. Are the underlying DataFrames mutable? If not, might optimize this\n        pm4py_ocel = deepcopy(self.ocel, memo)\n        ocel = OCEL(ocel=pm4py_ocel, meta=OCELMeta(extra=self.meta.extra))\n        return ocel\n\n    def __str__(self):\n        return f\"OCEL [{len(self.events.df)} events, {len(self.objects.df)} objects]\"\n\n    def __repr__(self):\n        return str(self)\n</code></pre>"},{"location":"references/core/#ocelescope.ocel.core.ocel.OCEL.filter","title":"filter","text":"<pre><code>filter(pipeline)\n</code></pre> <p>Apply a sequence of filters to this OCEL instance.</p> <p>Filters are executed in sequence, and their boolean masks are merged to produce a refined subset of events and objects. A new OCEL instance is returned containing only the items that satisfy all filters.</p> <p>Parameters:</p> Name Type Description Default <code>pipeline</code> <code>list[BaseFilter]</code> <p>A list of filter objects, each implementing a <code>filter()</code> method that returns a <code>FilterResult</code> mask.</p> required <p>Returns:</p> Name Type Description <code>OCEL</code> <code>OCEL</code> <p>A new OCEL instance representing the filtered view of the log.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/core/ocel.py</code> <pre><code>def filter(self, pipeline: list[BaseFilter]) -&gt; OCEL:\n    \"\"\"\n    Apply a sequence of filters to this OCEL instance.\n\n    Filters are executed in sequence, and their boolean masks are merged\n    to produce a refined subset of events and objects. A new OCEL instance\n    is returned containing only the items that satisfy all filters.\n\n    Args:\n        pipeline (list[BaseFilter]):\n            A list of filter objects, each implementing a ``filter()`` method\n            that returns a ``FilterResult`` mask.\n\n    Returns:\n        OCEL: A new OCEL instance representing the filtered view of the log.\n    \"\"\"\n    from ocelescope.ocel.filter.engine import apply_filters\n\n    return apply_filters(ocel=self, filters=pipeline)\n</code></pre>"},{"location":"references/core/#ocelescope.ocel.core.ocel.OCEL.read","title":"read  <code>staticmethod</code>","text":"<pre><code>read(path, meta={})\n</code></pre> <p>Read an OCEL file (.jsonocel, .xmlocel, or .sqlite) from disk.</p> <p>Automatically detects the file format based on extension and loads the OCEL into a structured wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the OCEL file on disk.</p> required <code>meta</code> <code>dict[str, Any]</code> <p>Additional metadata to attach to the OCELMeta container.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>OCEL</code> <code>OCEL</code> <p>A fully constructed OCEL wrapper instance.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/core/ocel.py</code> <pre><code>@staticmethod\ndef read(path: str | Path, meta: dict[str, Any] = {}) -&gt; OCEL:\n    \"\"\"\n    Read an OCEL file (.jsonocel, .xmlocel, or .sqlite) from disk.\n\n    Automatically detects the file format based on extension and loads the\n    OCEL into a structured wrapper.\n\n    Args:\n        path (str | Path):\n            Path to the OCEL file on disk.\n        meta (dict[str, Any], optional):\n            Additional metadata to attach to the OCELMeta container.\n\n    Returns:\n        OCEL: A fully constructed OCEL wrapper instance.\n    \"\"\"\n\n    path = Path(path)\n\n    with warnings.catch_warnings(record=True):\n        match path.suffix:\n            case \".sqlite\":\n                pm4py_ocel = pm4py.read.read_ocel2_sqlite(str(path))\n            case \".xmlocel\":\n                pm4py_ocel = pm4py.read.read_ocel2_xml(str(path))\n            case \".jsonocel\":\n                pm4py_ocel = pm4py.read.read_ocel2_json(str(path))\n            case _:\n                raise ValueError(f\"Unsupported extension: {path.suffix}\")\n\n    return OCEL(ocel=pm4py_ocel, meta=OCELMeta(path=path, extra=meta))\n</code></pre>"},{"location":"references/core/#ocelescope.ocel.core.ocel.OCEL.write","title":"write","text":"<pre><code>write(path)\n</code></pre> <p>Write the OCEL log and all registered extensions to disk.</p> <p>The output format is inferred from the file extension. Supported file types are:     - .jsonocel     - .xmlocel     - .sqlite</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Destination file path.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file extension is not supported.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/core/ocel.py</code> <pre><code>def write(self, path: str | Path):\n    \"\"\"\n    Write the OCEL log and all registered extensions to disk.\n\n    The output format is inferred from the file extension. Supported file\n    types are:\n        - .jsonocel\n        - .xmlocel\n        - .sqlite\n\n    Args:\n        path (str | Path):\n            Destination file path.\n\n    Raises:\n        ValueError: If the file extension is not supported.\n    \"\"\"\n    path = Path(path)\n\n    match path.suffix:\n        case \".xmlocel\":\n            pm4py.write_ocel2_xml(self.ocel, str(path))\n        case \".jsonocel\":\n            pm4py.write_ocel2_json(self.ocel, str(path))\n        case \".sqlite\":\n            pm4py.write_ocel2_sqlite(self.ocel, str(path))\n        case _:\n            raise ValueError(f\"Unsupported extension: {path.suffix}\")\n\n    self.extensions.export_all(path)\n</code></pre>"},{"location":"references/core/#ocelescope.ocel.models.meta.OCELMeta","title":"OCELMeta  <code>dataclass</code>","text":"<p>Metadata for an OCEL instance.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for this metadata/log instance.</p> <code>path</code> <code>Path | None</code> <p>Filesystem path from which this OCEL was loaded.</p> <code>extra</code> <code>dict[str, Any]</code> <p>Free-form metadata for user-defined fields.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/models/meta.py</code> <pre><code>@dataclass\nclass OCELMeta:\n    \"\"\"Metadata for an OCEL instance.\n\n    Attributes:\n        id: Unique identifier for this metadata/log instance.\n        path: Filesystem path from which this OCEL was loaded.\n        extra: Free-form metadata for user-defined fields.\n    \"\"\"\n\n    id: str = field(default_factory=uuid_factory)\n    path: Path | None = None\n    extra: dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"references/extensions/","title":"Extensions","text":""},{"location":"references/extensions/#ocelescope.ocel.extensions.ExtensionManager","title":"ExtensionManager","text":"<p>Manage loading, storing, and exporting OCEL file extensions.</p> <p>The ExtensionManager is responsible for: - Detecting which extensions exist for a given OCEL file - Loading those extensions via their import interfaces - Providing access to loaded extensions - Exporting all extension data during OCEL write operations</p> <p>Attributes:</p> Name Type Description <code>ocel</code> <p>The OCEL instance this manager belongs to.</p> <code>_extensions</code> <code>Dict[type[OCELExtension], OCELExtension]</code> <p>A mapping of extension classes to extension instances.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/extensions/manager.py</code> <pre><code>class ExtensionManager:\n    \"\"\"Manage loading, storing, and exporting OCEL file extensions.\n\n    The ExtensionManager is responsible for:\n    - Detecting which extensions exist for a given OCEL file\n    - Loading those extensions via their import interfaces\n    - Providing access to loaded extensions\n    - Exporting all extension data during OCEL write operations\n\n    Attributes:\n        ocel: The OCEL instance this manager belongs to.\n        _extensions: A mapping of extension classes to extension instances.\n    \"\"\"\n\n    def __init__(self, ocel: \"OCEL\"):\n        self.ocel = ocel\n        self._extensions: Dict[type[OCELExtension], OCELExtension] = {}\n\n    def load(self, extensions: list[type[OCELExtension]]):\n        \"\"\"Attempt to load the given extension classes from the OCEL file.\n\n        For each extension class, this method:\n        - Checks whether the file format is supported\n        - Detects whether the extension is present in the file\n        - Imports the extension if available\n        - Stores the loaded extension instance\n\n        Args:\n            extensions: A list of OCELExtension subclasses to check for and load.\n        \"\"\"\n\n        if not self.ocel.meta.path:\n            return\n\n        path = Path(self.ocel.meta.path)\n\n        for ext_cls in extensions:\n            try:\n                if path.suffix in getattr(ext_cls, \"supported_extensions\", []):\n                    if ext_cls.has_extension(path):\n                        instance = ext_cls.import_extension(self.ocel, path)\n                        self._extensions[ext_cls] = instance\n            except Exception as exc:\n                print(f\"[ExtensionManager] Failed to load {ext_cls.__name__}: {exc}\")\n\n    def get(self, ext_type: type[T]) -&gt; T | None:\n        \"\"\"Retrieve a loaded extension instance by its class.\n\n        Args:\n            ext_type: The extension class to retrieve.\n\n        Returns:\n            The loaded extension instance, or None if it has not been loaded.\n        \"\"\"\n        return self._extensions.get(ext_type)  # type: ignore\n\n    def all(self) -&gt; list[OCELExtension]:\n        \"\"\"Return all loaded extensions.\n\n        Returns:\n            A list of all extension instances currently managed.\n        \"\"\"\n        return list(self._extensions.values())\n\n    def export_all(self, target_path: Path):\n        \"\"\"Export all loaded extensions to disk.\n\n        Only extensions that support the target file's extension are exported.\n        Each extension defines how it writes its own data.\n\n        Args:\n            target_path: The destination path for the main OCEL file write.\n        \"\"\"\n        for ext in self._extensions.values():\n            try:\n                if target_path.suffix in getattr(ext, \"supported_extensions\", []):\n                    ext.export_extension(target_path)\n            except Exception as exc:\n                print(f\"[ExtensionManager] Failed to export {type(ext).__name__}: {exc}\")\n</code></pre>"},{"location":"references/extensions/#ocelescope.ocel.extensions.ExtensionManager.load","title":"load","text":"<pre><code>load(extensions)\n</code></pre> <p>Attempt to load the given extension classes from the OCEL file.</p> <p>For each extension class, this method: - Checks whether the file format is supported - Detects whether the extension is present in the file - Imports the extension if available - Stores the loaded extension instance</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>list[type[OCELExtension]]</code> <p>A list of OCELExtension subclasses to check for and load.</p> required Source code in <code>src/ocelescope/src/ocelescope/ocel/extensions/manager.py</code> <pre><code>def load(self, extensions: list[type[OCELExtension]]):\n    \"\"\"Attempt to load the given extension classes from the OCEL file.\n\n    For each extension class, this method:\n    - Checks whether the file format is supported\n    - Detects whether the extension is present in the file\n    - Imports the extension if available\n    - Stores the loaded extension instance\n\n    Args:\n        extensions: A list of OCELExtension subclasses to check for and load.\n    \"\"\"\n\n    if not self.ocel.meta.path:\n        return\n\n    path = Path(self.ocel.meta.path)\n\n    for ext_cls in extensions:\n        try:\n            if path.suffix in getattr(ext_cls, \"supported_extensions\", []):\n                if ext_cls.has_extension(path):\n                    instance = ext_cls.import_extension(self.ocel, path)\n                    self._extensions[ext_cls] = instance\n        except Exception as exc:\n            print(f\"[ExtensionManager] Failed to load {ext_cls.__name__}: {exc}\")\n</code></pre>"},{"location":"references/extensions/#ocelescope.ocel.extensions.ExtensionManager.get","title":"get","text":"<pre><code>get(ext_type)\n</code></pre> <p>Retrieve a loaded extension instance by its class.</p> <p>Parameters:</p> Name Type Description Default <code>ext_type</code> <code>type[T]</code> <p>The extension class to retrieve.</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>The loaded extension instance, or None if it has not been loaded.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/extensions/manager.py</code> <pre><code>def get(self, ext_type: type[T]) -&gt; T | None:\n    \"\"\"Retrieve a loaded extension instance by its class.\n\n    Args:\n        ext_type: The extension class to retrieve.\n\n    Returns:\n        The loaded extension instance, or None if it has not been loaded.\n    \"\"\"\n    return self._extensions.get(ext_type)  # type: ignore\n</code></pre>"},{"location":"references/extensions/#ocelescope.ocel.extensions.ExtensionManager.all","title":"all","text":"<pre><code>all()\n</code></pre> <p>Return all loaded extensions.</p> <p>Returns:</p> Type Description <code>list[OCELExtension]</code> <p>A list of all extension instances currently managed.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/extensions/manager.py</code> <pre><code>def all(self) -&gt; list[OCELExtension]:\n    \"\"\"Return all loaded extensions.\n\n    Returns:\n        A list of all extension instances currently managed.\n    \"\"\"\n    return list(self._extensions.values())\n</code></pre>"},{"location":"references/extensions/#ocelescope.ocel.extensions.ExtensionManager.export_all","title":"export_all","text":"<pre><code>export_all(target_path)\n</code></pre> <p>Export all loaded extensions to disk.</p> <p>Only extensions that support the target file's extension are exported. Each extension defines how it writes its own data.</p> <p>Parameters:</p> Name Type Description Default <code>target_path</code> <code>Path</code> <p>The destination path for the main OCEL file write.</p> required Source code in <code>src/ocelescope/src/ocelescope/ocel/extensions/manager.py</code> <pre><code>def export_all(self, target_path: Path):\n    \"\"\"Export all loaded extensions to disk.\n\n    Only extensions that support the target file's extension are exported.\n    Each extension defines how it writes its own data.\n\n    Args:\n        target_path: The destination path for the main OCEL file write.\n    \"\"\"\n    for ext in self._extensions.values():\n        try:\n            if target_path.suffix in getattr(ext, \"supported_extensions\", []):\n                ext.export_extension(target_path)\n        except Exception as exc:\n            print(f\"[ExtensionManager] Failed to export {type(ext).__name__}: {exc}\")\n</code></pre>"},{"location":"references/extensions/#ocelescope.ocel.extensions.OCELExtension","title":"OCELExtension","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for OCEL extensions that can be imported/exported from a file path.</p> Returned by: <ul> <li> References OCEL Extensions <code></code>\u00a0ExtensionManager <code></code>\u00a0all </li> </ul> Used by: <ul> <li> References OCEL Extensions <code></code>\u00a0ExtensionManager <code></code>\u00a0load </li> </ul> Source code in <code>src/ocelescope/src/ocelescope/ocel/extensions/base_extension.py</code> <pre><code>class OCELExtension(ABC):\n    \"\"\"\n    Abstract base class for OCEL extensions that can be imported/exported from a file path.\n    \"\"\"\n\n    name: str\n    description: str\n    version: str\n    supported_extensions: list[OCELFileExtensions]\n\n    @staticmethod\n    @abstractmethod\n    def has_extension(path: Path) -&gt; bool:\n        \"\"\"\n        Check if the extension data exists at the given path.\n        \"\"\"\n        pass\n\n    @classmethod\n    @abstractmethod\n    def import_extension(cls: type[T], ocel: \"OCEL\", path: Path) -&gt; T:\n        \"\"\"\n        Create the extension by reading from the given path.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def export_extension(self, path: Path) -&gt; None:\n        \"\"\"\n        Write the extension data to the given path.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"references/extensions/#ocelescope.ocel.extensions.OCELExtension.has_extension","title":"has_extension  <code>abstractmethod</code> <code>staticmethod</code>","text":"<pre><code>has_extension(path)\n</code></pre> <p>Check if the extension data exists at the given path.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/extensions/base_extension.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef has_extension(path: Path) -&gt; bool:\n    \"\"\"\n    Check if the extension data exists at the given path.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"references/extensions/#ocelescope.ocel.extensions.OCELExtension.import_extension","title":"import_extension  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>import_extension(ocel, path)\n</code></pre> <p>Create the extension by reading from the given path.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/extensions/base_extension.py</code> <pre><code>@classmethod\n@abstractmethod\ndef import_extension(cls: type[T], ocel: \"OCEL\", path: Path) -&gt; T:\n    \"\"\"\n    Create the extension by reading from the given path.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"references/extensions/#ocelescope.ocel.extensions.OCELExtension.export_extension","title":"export_extension  <code>abstractmethod</code>","text":"<pre><code>export_extension(path)\n</code></pre> <p>Write the extension data to the given path.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/extensions/base_extension.py</code> <pre><code>@abstractmethod\ndef export_extension(self, path: Path) -&gt; None:\n    \"\"\"\n    Write the extension data to the given path.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"references/filters/","title":"Filters","text":""},{"location":"references/managers/e2o/","title":"E2o","text":""},{"location":"references/managers/e2o/#ocelescope.ocel.managers.e2o.E2OManager","title":"E2OManager","text":"<p>               Bases: <code>BaseManager</code></p> <p>Manages event-to-object (E2O) relations within an OCEL instance.</p> Provides <ul> <li>Access to the raw E2O relation table</li> <li>A normalized E2O table using canonical column names</li> <li>Enriched E2O table including activity and object type information</li> <li>Aggregated multiplicity summaries for E2O relations</li> </ul> <p>This manager acts as a typed and normalized fa\u00e7ade over the PM4PY E2O relations.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/managers/e2o.py</code> <pre><code>class E2OManager(BaseManager):\n    \"\"\"\n    Manages event-to-object (E2O) relations within an OCEL instance.\n\n    Provides:\n        - Access to the raw E2O relation table\n        - A normalized E2O table using canonical column names\n        - Enriched E2O table including activity and object type information\n        - Aggregated multiplicity summaries for E2O relations\n\n    This manager acts as a typed and normalized fa\u00e7ade over the\n    PM4PY E2O relations.\n    \"\"\"\n\n    def __init__(self, ocel: \"OCEL\"):\n        super().__init__()\n        self._ocel = ocel\n\n    # ---------------------------------------------------------\n    # Raw \u2192 Normalized E2O DataFrame\n    # ---------------------------------------------------------\n    @property\n    def df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Return the E2O relation table with normalized column names.\n\n        PM4PY uses the following columns:\n            - \"ocel:eid\"\n            - \"ocel:oid\"\n            - \"ocel:type\"\n            - \"ocel:qualifier\"\n\n        This property renames them to canonical constants:\n            - E2O_EVENT_ID\n            - E2O_OBJECT_ID\n            - E2O_OBJECT_TYPE\n\n        Returns:\n            DataFrame: Normalized E2O relation table.\n        \"\"\"\n        raw = self._ocel.ocel.relations\n\n        return raw.rename(\n            columns={\n                \"ocel:eid\": E2O_EVENT_ID,\n                \"ocel:oid\": E2O_OBJECT_ID,\n                \"ocel:type\": E2O_OBJECT_TYPE,\n                \"ocel:activity\": E2O_ACTIVITY,\n            }\n        )\n\n    # ---------------------------------------------------------\n    # Typed / Enriched E2O Table\n    # ---------------------------------------------------------\n    @property\n    @instance_lru_cache()\n    def typed_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Return the E2O relation table enriched with:\n            - Event activity (from EventsManager)\n            - Object type (from ObjectsManager)\n\n        Columns added:\n            - E2O_ACTIVITY\n            - E2O_OBJECT_TYPE\n\n        Returns:\n            DataFrame: Type- and activity-enriched E2O table.\n        \"\"\"\n        df = self.df.copy()\n\n        # Join activity (via EventsManager)\n        activity_by_id = self._ocel.events.activity_by_id\n        df = df.join(activity_by_id.rename(E2O_ACTIVITY), on=E2O_EVENT_ID)\n\n        # Join object type (via ObjectsManager)\n        type_by_id = self._ocel.objects.type_by_id\n        df = df.join(type_by_id.rename(E2O_OBJECT_TYPE), on=E2O_OBJECT_ID)\n\n        return df\n\n    # ---------------------------------------------------------\n    # Summary\n    # ---------------------------------------------------------\n    @instance_lru_cache()\n    def summary(self, direction: SUMMARY_DIRECTION = \"source\") -&gt; list[RelationCountSummary]:\n        \"\"\"\n        Compute summary statistics for E2O relationships.\n\n        Summaries include min/max/total numbers of objects per event\n        or events per object, depending on relation direction.\n\n        Uses the shared utility `summarize_e2o_counts`.\n\n        Args:\n            direction (SUMMARY_DIRECTION, optional):\n                Whether the summary should be computed from the perspective\n                of the source object (``\"source\"``) or the target object\n                (``\"target\"``). Defaults to ``\"source\"``.\n\n\n        Returns:\n            list[RelationCountSummary]:\n                A list of structured summaries of E2O relations.\n        \"\"\"\n        return summarize_e2o_counts(self._ocel.ocel, direction)\n</code></pre>"},{"location":"references/managers/e2o/#ocelescope.ocel.managers.e2o.E2OManager.df","title":"df  <code>property</code>","text":"<pre><code>df\n</code></pre> <p>Return the E2O relation table with normalized column names.</p> PM4PY uses the following columns <ul> <li>\"ocel:eid\"</li> <li>\"ocel:oid\"</li> <li>\"ocel:type\"</li> <li>\"ocel:qualifier\"</li> </ul> This property renames them to canonical constants <ul> <li>E2O_EVENT_ID</li> <li>E2O_OBJECT_ID</li> <li>E2O_OBJECT_TYPE</li> </ul> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Normalized E2O relation table.</p>"},{"location":"references/managers/e2o/#ocelescope.ocel.managers.e2o.E2OManager.typed_df","title":"typed_df  <code>property</code>","text":"<pre><code>typed_df\n</code></pre> Return the E2O relation table enriched with <ul> <li>Event activity (from EventsManager)</li> <li>Object type (from ObjectsManager)</li> </ul> Columns added <ul> <li>E2O_ACTIVITY</li> <li>E2O_OBJECT_TYPE</li> </ul> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Type- and activity-enriched E2O table.</p>"},{"location":"references/managers/e2o/#ocelescope.ocel.managers.e2o.E2OManager.summary","title":"summary","text":"<pre><code>summary(direction='source')\n</code></pre> <p>Compute summary statistics for E2O relationships.</p> <p>Summaries include min/max/total numbers of objects per event or events per object, depending on relation direction.</p> <p>Uses the shared utility <code>summarize_e2o_counts</code>.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>SUMMARY_DIRECTION</code> <p>Whether the summary should be computed from the perspective of the source object (<code>\"source\"</code>) or the target object (<code>\"target\"</code>). Defaults to <code>\"source\"</code>.</p> <code>'source'</code> <p>Returns:</p> Type Description <code>list[RelationCountSummary]</code> <p>list[RelationCountSummary]: A list of structured summaries of E2O relations.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/managers/e2o.py</code> <pre><code>@instance_lru_cache()\ndef summary(self, direction: SUMMARY_DIRECTION = \"source\") -&gt; list[RelationCountSummary]:\n    \"\"\"\n    Compute summary statistics for E2O relationships.\n\n    Summaries include min/max/total numbers of objects per event\n    or events per object, depending on relation direction.\n\n    Uses the shared utility `summarize_e2o_counts`.\n\n    Args:\n        direction (SUMMARY_DIRECTION, optional):\n            Whether the summary should be computed from the perspective\n            of the source object (``\"source\"``) or the target object\n            (``\"target\"``). Defaults to ``\"source\"``.\n\n\n    Returns:\n        list[RelationCountSummary]:\n            A list of structured summaries of E2O relations.\n    \"\"\"\n    return summarize_e2o_counts(self._ocel.ocel, direction)\n</code></pre>"},{"location":"references/managers/events/","title":"Events","text":""},{"location":"references/managers/events/#ocelescope.ocel.managers.events.EventsManager","title":"EventsManager","text":"<p>               Bases: <code>BaseManager</code></p> <p>Manages event-level information within an OCEL instance.</p> <p>Provides access to: - the events table - event activities and activity counts - activity lookup by event ID - event attribute names - structured summaries of event attributes</p> <p>Acts as a facade over the underlying PM4PY OCEL object.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/managers/events.py</code> <pre><code>class EventsManager(BaseManager):\n    \"\"\"\n    Manages event-level information within an OCEL instance.\n\n    Provides access to:\n    - the events table\n    - event activities and activity counts\n    - activity lookup by event ID\n    - event attribute names\n    - structured summaries of event attributes\n\n    Acts as a facade over the underlying PM4PY OCEL object.\n    \"\"\"\n\n    def __init__(self, ocel: \"OCEL\"):\n        super().__init__()\n        self._ocel = ocel\n\n    @property\n    def df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Return the event table from the underlying OCEL.\n\n        Returns:\n            DataFrame: A pandas DataFrame containing all events and their attributes.\n        \"\"\"\n        return self._ocel.ocel.events\n\n    @property\n    @instance_lru_cache()\n    def activities(self) -&gt; list[str]:\n        \"\"\"\n        Return all activity names present in the log.\n\n        Returns:\n            list[str]: A sorted list of unique activity names.\n        \"\"\"\n        return list(sorted(self.df[ACTIVITY_COL].unique().tolist()))\n\n    @property\n    @instance_lru_cache()\n    def activity_counts(self) -&gt; pd.Series:\n        \"\"\"\n        Return the frequency of each activity in the log.\n\n        Returns:\n            Series: A pandas Series indexed by activity name with occurrence counts.\n        \"\"\"\n        return self.df[ACTIVITY_COL].value_counts()\n\n    @property\n    @instance_lru_cache()\n    def activity_by_id(self) -&gt; pd.Series:\n        \"\"\"\n        Return a mapping from event ID to activity.\n\n        Returns:\n            Series: A pandas Series indexed by event ID, containing activity names as values.\n        \"\"\"\n        return cast(pd.Series, self.df[[EID_COL, ACTIVITY_COL]].set_index(EID_COL)[ACTIVITY_COL])\n\n    @property\n    def attribute_names(self) -&gt; list[str]:\n        \"\"\"\n        Return the names of all event attributes.\n\n        Returns:\n            list[str]: A sorted list of event attribute names.\n        \"\"\"\n        return sorted([col for col in self.df.columns if not col.startswith(\"ocel:\")])\n\n    @property\n    @instance_lru_cache()\n    def attribute_summary(self) -&gt; dict[str, list[AttributeSummary]]:\n        \"\"\"\n        Summarize all event attributes grouped by activity.\n\n        Returns:\n            dict[str, list[AttributeSummary]]: Mapping of activities to\n            lists of structured attribute summaries.\n        \"\"\"\n        return summarize_event_attributes(self._ocel.ocel)\n</code></pre>"},{"location":"references/managers/events/#ocelescope.ocel.managers.events.EventsManager.df","title":"df  <code>property</code>","text":"<pre><code>df\n</code></pre> <p>Return the event table from the underlying OCEL.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A pandas DataFrame containing all events and their attributes.</p>"},{"location":"references/managers/events/#ocelescope.ocel.managers.events.EventsManager.activities","title":"activities  <code>property</code>","text":"<pre><code>activities\n</code></pre> <p>Return all activity names present in the log.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A sorted list of unique activity names.</p>"},{"location":"references/managers/events/#ocelescope.ocel.managers.events.EventsManager.activity_counts","title":"activity_counts  <code>property</code>","text":"<pre><code>activity_counts\n</code></pre> <p>Return the frequency of each activity in the log.</p> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>A pandas Series indexed by activity name with occurrence counts.</p>"},{"location":"references/managers/events/#ocelescope.ocel.managers.events.EventsManager.activity_by_id","title":"activity_by_id  <code>property</code>","text":"<pre><code>activity_by_id\n</code></pre> <p>Return a mapping from event ID to activity.</p> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>A pandas Series indexed by event ID, containing activity names as values.</p>"},{"location":"references/managers/events/#ocelescope.ocel.managers.events.EventsManager.attribute_names","title":"attribute_names  <code>property</code>","text":"<pre><code>attribute_names\n</code></pre> <p>Return the names of all event attributes.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A sorted list of event attribute names.</p>"},{"location":"references/managers/events/#ocelescope.ocel.managers.events.EventsManager.attribute_summary","title":"attribute_summary  <code>property</code>","text":"<pre><code>attribute_summary\n</code></pre> <p>Summarize all event attributes grouped by activity.</p> <p>Returns:</p> Type Description <code>dict[str, list[AttributeSummary]]</code> <p>dict[str, list[AttributeSummary]]: Mapping of activities to</p> <code>dict[str, list[AttributeSummary]]</code> <p>lists of structured attribute summaries.</p>"},{"location":"references/managers/o2o/","title":"O2o","text":""},{"location":"references/managers/o2o/#ocelescope.ocel.managers.o2o.O2OManager","title":"O2OManager","text":"<p>               Bases: <code>BaseManager</code></p> <p>Manages object-to-object (O2O) relations within an OCEL instance.</p> Provides <ul> <li>Access to the raw O2O relation table</li> <li>A normalized O2O table using canonical constant column names</li> <li>Type-enriched O2O relations (joining object types)</li> <li>Aggregated summaries of O2O relation multiplicities</li> </ul> <p>This manager acts as a typed and normalized facade over the PM4PY O2O relation table.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/managers/o2o.py</code> <pre><code>class O2OManager(BaseManager):\n    \"\"\"\n    Manages object-to-object (O2O) relations within an OCEL instance.\n\n    Provides:\n        - Access to the raw O2O relation table\n        - A normalized O2O table using canonical constant column names\n        - Type-enriched O2O relations (joining object types)\n        - Aggregated summaries of O2O relation multiplicities\n\n    This manager acts as a typed and normalized facade over the\n    PM4PY O2O relation table.\n    \"\"\"\n\n    def __init__(self, ocel: \"OCEL\"):\n        super().__init__()\n        self._ocel = ocel\n\n    @property\n    def df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Return the O2O relation table with normalized column names.\n\n        PM4PY uses mixed naming conventions for O2O relations\n        (e.g., \"ocel:oid\" and \"ocel:oid_2\").\n        This property maps these raw names to canonical constants:\n\n            - O2O_SOURCE_ID\n            - O2O_TARGET_ID\n\n        Returns:\n            DataFrame: A normalized O2O relation table.\n        \"\"\"\n        raw = self._ocel.ocel.o2o\n\n        return raw.rename(\n            columns={\n                \"ocel:oid\": O2O_SOURCE_ID,\n                \"ocel:oid_2\": O2O_TARGET_ID,\n            }\n        )\n\n    @property\n    @instance_lru_cache()\n    def typed_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Return the O2O relation table enriched with object types.\n\n        Adds two additional columns to the normalized O2O table:\n\n            - O2O_SOURCE_TYPE\n            - O2O_TARGET_TYPE\n\n        These are obtained by joining against the object manager\u2019s\n        `type_by_id` Series.\n\n        Returns:\n            DataFrame: A type-enriched O2O relation table.\n        \"\"\"\n        type_by_id: pd.Series = self._ocel.objects.type_by_id\n\n        df = self.df.copy()\n\n        df = df.join(type_by_id.rename(O2O_SOURCE_TYPE), on=O2O_SOURCE_ID)\n        df = df.join(type_by_id.rename(O2O_TARGET_TYPE), on=O2O_TARGET_ID)\n\n        return df\n\n    @instance_lru_cache()\n    def summary(self, direction: SUMMARY_DIRECTION = \"source\") -&gt; list[RelationCountSummary]:\n        \"\"\"\n        Compute summary statistics for O2O relationships.\n\n        Summaries include min/max/total numbers of target objects\n        per source object, grouped by qualifier and type.\n\n        Args:\n            direction (SUMMARY_DIRECTION, optional):\n                Whether the summary should be computed from the perspective\n                of the source object (``\"source\"``) or the target object\n                (``\"target\"``). Defaults to ``\"source\"``.\n\n        Returns:\n            list[RelationCountSummary]:\n                A list of structured relation count summaries.\n        \"\"\"\n        return summarize_o2o_counts(self._ocel.ocel, direction)\n</code></pre>"},{"location":"references/managers/o2o/#ocelescope.ocel.managers.o2o.O2OManager.df","title":"df  <code>property</code>","text":"<pre><code>df\n</code></pre> <p>Return the O2O relation table with normalized column names.</p> <p>PM4PY uses mixed naming conventions for O2O relations (e.g., \"ocel:oid\" and \"ocel:oid_2\"). This property maps these raw names to canonical constants:</p> <pre><code>- O2O_SOURCE_ID\n- O2O_TARGET_ID\n</code></pre> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A normalized O2O relation table.</p>"},{"location":"references/managers/o2o/#ocelescope.ocel.managers.o2o.O2OManager.typed_df","title":"typed_df  <code>property</code>","text":"<pre><code>typed_df\n</code></pre> <p>Return the O2O relation table enriched with object types.</p> <p>Adds two additional columns to the normalized O2O table:</p> <pre><code>- O2O_SOURCE_TYPE\n- O2O_TARGET_TYPE\n</code></pre> <p>These are obtained by joining against the object manager\u2019s <code>type_by_id</code> Series.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A type-enriched O2O relation table.</p>"},{"location":"references/managers/o2o/#ocelescope.ocel.managers.o2o.O2OManager.summary","title":"summary","text":"<pre><code>summary(direction='source')\n</code></pre> <p>Compute summary statistics for O2O relationships.</p> <p>Summaries include min/max/total numbers of target objects per source object, grouped by qualifier and type.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>SUMMARY_DIRECTION</code> <p>Whether the summary should be computed from the perspective of the source object (<code>\"source\"</code>) or the target object (<code>\"target\"</code>). Defaults to <code>\"source\"</code>.</p> <code>'source'</code> <p>Returns:</p> Type Description <code>list[RelationCountSummary]</code> <p>list[RelationCountSummary]: A list of structured relation count summaries.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/managers/o2o.py</code> <pre><code>@instance_lru_cache()\ndef summary(self, direction: SUMMARY_DIRECTION = \"source\") -&gt; list[RelationCountSummary]:\n    \"\"\"\n    Compute summary statistics for O2O relationships.\n\n    Summaries include min/max/total numbers of target objects\n    per source object, grouped by qualifier and type.\n\n    Args:\n        direction (SUMMARY_DIRECTION, optional):\n            Whether the summary should be computed from the perspective\n            of the source object (``\"source\"``) or the target object\n            (``\"target\"``). Defaults to ``\"source\"``.\n\n    Returns:\n        list[RelationCountSummary]:\n            A list of structured relation count summaries.\n    \"\"\"\n    return summarize_o2o_counts(self._ocel.ocel, direction)\n</code></pre>"},{"location":"references/managers/objects/","title":"Objects","text":""},{"location":"references/managers/objects/#ocelescope.ocel.managers.objects.ObjectsManager","title":"ObjectsManager","text":"<p>               Bases: <code>BaseManager</code></p> <p>Manages object-level information within an OCEL instance.</p> <p>Provides access to: - the objects table - the object_changes table - object types and counts - object attribute names - per-object lookup helpers such as type-by-id</p> <p>Acts as a facade over the underlying PM4PY OCEL object.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/managers/objects.py</code> <pre><code>class ObjectsManager(BaseManager):\n    \"\"\"\n    Manages object-level information within an OCEL instance.\n\n    Provides access to:\n    - the objects table\n    - the object_changes table\n    - object types and counts\n    - object attribute names\n    - per-object lookup helpers such as type-by-id\n\n    Acts as a facade over the underlying PM4PY OCEL object.\n    \"\"\"\n\n    def __init__(self, ocel: \"OCEL\"):\n        super().__init__()\n        self._ocel = ocel\n\n    @property\n    def df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Return the object table from the underlying OCEL.\n\n        Returns:\n            DataFrame: A pandas DataFrame containing all objects and their static attributes.\n        \"\"\"\n        return self._ocel.ocel.objects\n\n    @property\n    def changes(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Return the dynamic object attribute change table.\n\n        Returns:\n            DataFrame: A pandas DataFrame containing all dynamic updates to object attributes.\n        \"\"\"\n        return self._ocel.ocel.object_changes\n\n    @property\n    @instance_lru_cache()\n    def types(self) -&gt; list[str]:\n        \"\"\"\n        Return the list of all object types present in the log.\n\n        Returns:\n            list[str]: Sorted list of unique object type names.\n        \"\"\"\n        return list(sorted(self.df[OTYPE_COL].unique().tolist()))\n\n    @property\n    @instance_lru_cache()\n    def counts(self) -&gt; pd.Series:\n        \"\"\"\n        Count how many objects exist for each object type.\n\n        Returns:\n            Series: A pandas Series indexed by object type with occurrence counts.\n        \"\"\"\n        return self.df[OTYPE_COL].value_counts()\n\n    @property\n    @instance_lru_cache()\n    def type_by_id(self) -&gt; pd.Series:\n        \"\"\"\n        Return a mapping from object ID to object type.\n\n        Returns:\n            Series: A pandas Series indexed by object ID, containing object types as values.\n        \"\"\"\n        return cast(pd.Series, self.df[[OID_COL, OTYPE_COL]].set_index(OID_COL)[OTYPE_COL])\n\n    def has_types(self, types: Iterable[str]) -&gt; bool:\n        \"\"\"\n        Check whether all provided object types exist in the OCEL.\n\n        Args:\n            types: Iterable of object type names to verify.\n\n        Returns:\n            bool: True if all types exist, False otherwise.\n        \"\"\"\n        return all(ot in self.types for ot in types)\n\n    @property\n    def static_attribute_names(self) -&gt; list[str]:\n        \"\"\"\n        Return the names of all static object attributes.\n\n        Static attributes are non-OCEL-prefixed columns in the objects\n        table that contain at least one non-null value.\n\n        Returns:\n            list[str]: Sorted list of static object attribute names.\n        \"\"\"\n        return sorted(\n            [col for col in self.df.columns[self.df.count() &gt; 0] if not col.startswith(\"ocel:\")]\n        )\n\n    @property\n    def dynamic_attribute_names(self) -&gt; list[str]:\n        \"\"\"\n        Return the names of all dynamic object attributes.\n\n        Dynamic attributes are derived from the object_changes table,\n        excluding OCEL system columns and internal counters.\n\n        Returns:\n            list[str]: Sorted list of dynamic object attribute names.\n        \"\"\"\n        return sorted(\n            [\n                col\n                for col in self.changes.columns[self.changes.count() &gt; 0]\n                if not col.startswith(\"ocel:\") and col != \"@@cumcount\"\n            ]\n        )\n\n    @property\n    def attribute_names(self) -&gt; list[str]:\n        \"\"\"\n        Return all object attribute names.\n\n        Combines both static and dynamic attributes into a unified list.\n\n        Returns:\n            list[str]: Sorted list of all object attribute names.\n        \"\"\"\n        return sorted(set(self.static_attribute_names + self.dynamic_attribute_names))\n\n    @property\n    @instance_lru_cache()\n    def attribute_summary(self) -&gt; dict[str, list[AttributeSummary]]:\n        \"\"\"\n        Summarize all object attributes grouped by object type.\n\n        Summaries include inferred attribute data types, ranges,\n        value distributions, and other type-specific metadata.\n\n        Returns:\n            dict[str, list[AttributeSummary]]: Mapping of object types to\n            lists of structured attribute summaries.\n        \"\"\"\n        return summarize_object_attributes(self._ocel.ocel)\n</code></pre>"},{"location":"references/managers/objects/#ocelescope.ocel.managers.objects.ObjectsManager.df","title":"df  <code>property</code>","text":"<pre><code>df\n</code></pre> <p>Return the object table from the underlying OCEL.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A pandas DataFrame containing all objects and their static attributes.</p>"},{"location":"references/managers/objects/#ocelescope.ocel.managers.objects.ObjectsManager.changes","title":"changes  <code>property</code>","text":"<pre><code>changes\n</code></pre> <p>Return the dynamic object attribute change table.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A pandas DataFrame containing all dynamic updates to object attributes.</p>"},{"location":"references/managers/objects/#ocelescope.ocel.managers.objects.ObjectsManager.types","title":"types  <code>property</code>","text":"<pre><code>types\n</code></pre> <p>Return the list of all object types present in the log.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Sorted list of unique object type names.</p>"},{"location":"references/managers/objects/#ocelescope.ocel.managers.objects.ObjectsManager.counts","title":"counts  <code>property</code>","text":"<pre><code>counts\n</code></pre> <p>Count how many objects exist for each object type.</p> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>A pandas Series indexed by object type with occurrence counts.</p>"},{"location":"references/managers/objects/#ocelescope.ocel.managers.objects.ObjectsManager.type_by_id","title":"type_by_id  <code>property</code>","text":"<pre><code>type_by_id\n</code></pre> <p>Return a mapping from object ID to object type.</p> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>A pandas Series indexed by object ID, containing object types as values.</p>"},{"location":"references/managers/objects/#ocelescope.ocel.managers.objects.ObjectsManager.static_attribute_names","title":"static_attribute_names  <code>property</code>","text":"<pre><code>static_attribute_names\n</code></pre> <p>Return the names of all static object attributes.</p> <p>Static attributes are non-OCEL-prefixed columns in the objects table that contain at least one non-null value.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Sorted list of static object attribute names.</p>"},{"location":"references/managers/objects/#ocelescope.ocel.managers.objects.ObjectsManager.dynamic_attribute_names","title":"dynamic_attribute_names  <code>property</code>","text":"<pre><code>dynamic_attribute_names\n</code></pre> <p>Return the names of all dynamic object attributes.</p> <p>Dynamic attributes are derived from the object_changes table, excluding OCEL system columns and internal counters.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Sorted list of dynamic object attribute names.</p>"},{"location":"references/managers/objects/#ocelescope.ocel.managers.objects.ObjectsManager.attribute_names","title":"attribute_names  <code>property</code>","text":"<pre><code>attribute_names\n</code></pre> <p>Return all object attribute names.</p> <p>Combines both static and dynamic attributes into a unified list.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Sorted list of all object attribute names.</p>"},{"location":"references/managers/objects/#ocelescope.ocel.managers.objects.ObjectsManager.attribute_summary","title":"attribute_summary  <code>property</code>","text":"<pre><code>attribute_summary\n</code></pre> <p>Summarize all object attributes grouped by object type.</p> <p>Summaries include inferred attribute data types, ranges, value distributions, and other type-specific metadata.</p> <p>Returns:</p> Type Description <code>dict[str, list[AttributeSummary]]</code> <p>dict[str, list[AttributeSummary]]: Mapping of object types to</p> <code>dict[str, list[AttributeSummary]]</code> <p>lists of structured attribute summaries.</p>"},{"location":"references/managers/objects/#ocelescope.ocel.managers.objects.ObjectsManager.has_types","title":"has_types","text":"<pre><code>has_types(types)\n</code></pre> <p>Check whether all provided object types exist in the OCEL.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>Iterable[str]</code> <p>Iterable of object type names to verify.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all types exist, False otherwise.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/managers/objects.py</code> <pre><code>def has_types(self, types: Iterable[str]) -&gt; bool:\n    \"\"\"\n    Check whether all provided object types exist in the OCEL.\n\n    Args:\n        types: Iterable of object type names to verify.\n\n    Returns:\n        bool: True if all types exist, False otherwise.\n    \"\"\"\n    return all(ot in self.types for ot in types)\n</code></pre>"},{"location":"references/models/attributes/","title":"Attributes","text":""},{"location":"references/models/attributes/#ocelescope.ocel.models.attributes.AttributeSummary","title":"AttributeSummary  <code>module-attribute</code>","text":"<pre><code>AttributeSummary = Annotated[IntegerAttribute | FloatAttribute | BooleanAttribute | DateAttribute | NominalAttribute, Field(discriminator='type')]\n</code></pre> <p>Union type for all supported attribute summary structures.</p> <p>This type is used as the return value for attribute summarization, where each attribute is represented by one of the specialized summary dataclasses depending on its inferred type.</p> <p>The <code>type</code> field is used as a discriminator, enabling Pydantic to correctly parse the variant.</p> Possible variants <ul> <li>IntegerAttribute</li> <li>FloatAttribute</li> <li>BooleanAttribute</li> <li>DateAttribute</li> <li>NominalAttribute</li> </ul> Returned by: <ul> <li> References OCEL Managers Events <code></code>\u00a0EventsManager <code></code>\u00a0attribute_summary </li> <li> References OCEL Managers Objects <code></code>\u00a0ObjectsManager <code></code>\u00a0attribute_summary </li> </ul>"},{"location":"references/models/attributes/#ocelescope.ocel.models.attributes.IntegerAttribute","title":"IntegerAttribute  <code>dataclass</code>","text":"<p>Summary information for an integer attribute.</p> <p>Attributes:</p> Name Type Description <code>attribute</code> <code>str</code> <p>Name of the attribute.</p> <code>type</code> <code>Literal['integer']</code> <p>The attribute\u2019s inferred data type (\"integer\").</p> <code>min</code> <code>int</code> <p>The minimum observed value.</p> <code>max</code> <code>int</code> <p>The maximum observed value.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/models/attributes.py</code> <pre><code>@dataclass\nclass IntegerAttribute:\n    \"\"\"\n    Summary information for an integer attribute.\n\n    Attributes:\n        attribute (str):\n            Name of the attribute.\n        type (Literal[\"integer\"]):\n            The attribute\u2019s inferred data type (\"integer\").\n        min (int):\n            The minimum observed value.\n        max (int):\n            The maximum observed value.\n    \"\"\"\n\n    attribute: str\n    type: Literal[\"integer\"]\n    min: int\n    max: int\n</code></pre>"},{"location":"references/models/attributes/#ocelescope.ocel.models.attributes.FloatAttribute","title":"FloatAttribute  <code>dataclass</code>","text":"<p>Summary information for a floating-point numerical attribute.</p> <p>Attributes:</p> Name Type Description <code>attribute</code> <code>str</code> <p>Name of the attribute.</p> <code>type</code> <code>Literal['float']</code> <p>The attribute\u2019s inferred data type (\"float\").</p> <code>min</code> <code>float</code> <p>The minimum observed value.</p> <code>max</code> <code>float</code> <p>The maximum observed value.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/models/attributes.py</code> <pre><code>@dataclass\nclass FloatAttribute:\n    \"\"\"\n    Summary information for a floating-point numerical attribute.\n\n    Attributes:\n        attribute (str):\n            Name of the attribute.\n        type (Literal[\"float\"]):\n            The attribute\u2019s inferred data type (\"float\").\n        min (float):\n            The minimum observed value.\n        max (float):\n            The maximum observed value.\n    \"\"\"\n\n    attribute: str\n    type: Literal[\"float\"]\n    min: float\n    max: float\n</code></pre>"},{"location":"references/models/attributes/#ocelescope.ocel.models.attributes.BooleanAttribute","title":"BooleanAttribute  <code>dataclass</code>","text":"<p>Summary information for a boolean attribute.</p> <p>Attributes:</p> Name Type Description <code>attribute</code> <code>str</code> <p>Name of the attribute.</p> <code>type</code> <code>Literal['boolean']</code> <p>The attribute\u2019s inferred data type (\"boolean\").</p> <code>true_count</code> <code>int</code> <p>Number of events or objects where the value was True.</p> <code>false_count</code> <code>int</code> <p>Number of events or objects where the value was False.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/models/attributes.py</code> <pre><code>@dataclass\nclass BooleanAttribute:\n    \"\"\"\n    Summary information for a boolean attribute.\n\n    Attributes:\n        attribute (str):\n            Name of the attribute.\n        type (Literal[\"boolean\"]):\n            The attribute\u2019s inferred data type (\"boolean\").\n        true_count (int):\n            Number of events or objects where the value was True.\n        false_count (int):\n            Number of events or objects where the value was False.\n    \"\"\"\n\n    attribute: str\n    type: Literal[\"boolean\"]\n    true_count: int\n    false_count: int\n</code></pre>"},{"location":"references/models/attributes/#ocelescope.ocel.models.attributes.DateAttribute","title":"DateAttribute  <code>dataclass</code>","text":"<p>Summary information for a date or timestamp attribute.</p> <p>Attributes:</p> Name Type Description <code>attribute</code> <code>str</code> <p>Name of the attribute.</p> <code>type</code> <code>Literal['date']</code> <p>The attribute\u2019s inferred data type (\"date\").</p> <code>min</code> <code>str</code> <p>The earliest observed value (ISO timestamp string).</p> <code>max</code> <code>str</code> <p>The latest observed value (ISO timestamp string).</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/models/attributes.py</code> <pre><code>@dataclass\nclass DateAttribute:\n    \"\"\"\n    Summary information for a date or timestamp attribute.\n\n    Attributes:\n        attribute (str):\n            Name of the attribute.\n        type (Literal[\"date\"]):\n            The attribute\u2019s inferred data type (\"date\").\n        min (str):\n            The earliest observed value (ISO timestamp string).\n        max (str):\n            The latest observed value (ISO timestamp string).\n    \"\"\"\n\n    attribute: str\n    type: Literal[\"date\"]\n    min: str\n    max: str\n</code></pre>"},{"location":"references/models/attributes/#ocelescope.ocel.models.attributes.NominalAttribute","title":"NominalAttribute  <code>dataclass</code>","text":"<p>Summary information for a categorical (nominal) attribute.</p> <p>Attributes:</p> Name Type Description <code>attribute</code> <code>str</code> <p>Name of the attribute.</p> <code>type</code> <code>Literal['nominal']</code> <p>The attribute\u2019s inferred data type (\"nominal\").</p> <code>num_unique</code> <code>int</code> <p>Number of distinct categories observed.</p> Source code in <code>src/ocelescope/src/ocelescope/ocel/models/attributes.py</code> <pre><code>@dataclass\nclass NominalAttribute:\n    \"\"\"\n    Summary information for a categorical (nominal) attribute.\n\n    Attributes:\n        attribute (str):\n            Name of the attribute.\n        type (Literal[\"nominal\"]):\n            The attribute\u2019s inferred data type (\"nominal\").\n        num_unique (int):\n            Number of distinct categories observed.\n    \"\"\"\n\n    attribute: str\n    type: Literal[\"nominal\"]\n    num_unique: int\n</code></pre>"},{"location":"references/models/relations/","title":"Relations","text":""},{"location":"references/models/relations/#ocelescope.ocel.models.relations.RelationCountSummary","title":"RelationCountSummary  <code>dataclass</code>","text":"<p>Summary statistics for relationship multiplicities in O2O or E2O relations.</p> <p>This structure captures how many related objects (or events) occur for each combination of source type, target type, and qualifier. It is typically used in relation summaries such as those produced by O2OManager.summary or E2OManager.summary.</p> <p>Attributes:</p> Name Type Description <code>qualifier</code> <code>str</code> <p>The relation qualifier (e.g., role, relationship type) used in the OCEL relation. For O2O this is often empty; for E2O this may describe the nature of the event\u2013object link.</p> <code>source</code> <code>str</code> <p>The source object or event type associated with the relation.</p> <code>target</code> <code>str</code> <p>The target object or event type associated with the relation.</p> <code>min_count</code> <code>int</code> <p>The minimum number of related items observed for any source instance.</p> <code>max_count</code> <code>int</code> <p>The maximum number of related items observed for any source instance.</p> <code>sum</code> <code>int</code> <p>The total number of relation occurrences across all instances.</p> Returned by: <ul> <li> References OCEL Managers E2o <code></code>\u00a0E2OManager <code></code>\u00a0summary </li> <li> References OCEL Managers O2o <code></code>\u00a0O2OManager <code></code>\u00a0summary </li> </ul> Source code in <code>src/ocelescope/src/ocelescope/ocel/models/relations.py</code> <pre><code>@dataclass\nclass RelationCountSummary:\n    \"\"\"\n    Summary statistics for relationship multiplicities in O2O or E2O relations.\n\n    This structure captures how many related objects (or events) occur for each\n    combination of source type, target type, and qualifier. It is typically used\n    in relation summaries such as those produced by O2OManager.summary or\n    E2OManager.summary.\n\n    Attributes:\n        qualifier (str):\n            The relation qualifier (e.g., role, relationship type) used in the\n            OCEL relation. For O2O this is often empty; for E2O this may describe\n            the nature of the event\u2013object link.\n        source (str):\n            The source object or event type associated with the relation.\n        target (str):\n            The target object or event type associated with the relation.\n        min_count (int):\n            The minimum number of related items observed for any source instance.\n        max_count (int):\n            The maximum number of related items observed for any source instance.\n        sum (int):\n            The total number of relation occurrences across all instances.\n    \"\"\"\n\n    qualifier: str\n    source: str\n    target: str\n    min_count: int\n    max_count: int\n    sum: int\n</code></pre>"}]}